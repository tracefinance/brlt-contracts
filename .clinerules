# AI Development Assistant Guidelines

## Table of Contents
1. [Introduction](#introduction)
2. [Git Workflow](#git-workflow)
3. [Go Development Guidelines](#go-development-guidelines)
4. [Next.js Development Guidelines](#nextjs-development-guidelines)
5. [Smart Contract Development Guidelines](#smart-contract-development-guidelines)

## Introduction
This document provides structured guidelines for AI assistance with development tasks across different domains in the vault0 project. Follow these instructions carefully when providing code, recommendations, or documentation.

## Git Workflow

### Commit Conventions
- Use Angular commit convention with prefixes: `feat`, `fix`, `chore`, `refactor`, `docs`, `tests`
- Keep commit titles brief and descriptive
- Include detailed explanations in the commit body
- Use `git diff | cat` to view differences without locking the terminal
- For multi-line commit messages, use separate `-m` parameters for each line

## Go Development Guidelines

### Core Principles
- Follow user requirements precisely
- Plan before implementation with step-by-step pseudocode
- Write idiomatic Go code emphasizing clarity, simplicity, and maintainability
- Prioritize readability and proper error handling
- Implement all requested functionality completely (no TODOs)
- Include all necessary imports with proper component naming

### Code Style and Best Practices
- Use early returns for error handling to minimize nesting
- Provide error context with `fmt.Errorf("context: %w", err)`
- Use meaningful variable and function names
- Include proper API documentation comments
- Implement context-aware database operations
- Follow standard Go project layout conventions
- Use prepared statements for SQL queries (prevent injection)
- Implement proper input validation
- Use structured logging instead of fmt.Println/log.Printf
- Organize code into maintainable, testable packages
- Implement appropriate middleware for cross-cutting concerns

### Project Architecture
The backend uses a three-layer architecture:

#### 1. Core/Infrastructure Layer (`internal/core/`)
Foundation modules including:
- Database access and query execution
- Wallet operations (low-level functionality)
- Keystore (secure cryptographic key storage)
- Blockchain interaction
- Cryptography utilities
- Smart contract operation abstraction
- Key generation utilities

#### 2. Service Layer (`internal/services/`)
Business logic organized by domain:
- Domain-specific models
- Business operations and validation
- Repository interfaces for data access
- Includes: user management, wallet administration, authentication, transactions, blockchain integration

#### 3. Communication Layer (`internal/api/`)
External interfaces exposing functionality:
- RESTful API endpoints
- Request/response handling
- Middleware (auth, logging, error handling)
- Route management

### Project Structure
```
vault0/
├── cmd/                                # Command-line applications
│   ├── server/                         # Main server application
│   │   └── main.go                     # Application entry point
│   └── genkey/                         # Encryption key generation utility
│       └── main.go                     # Key generation entry point
├── internal/                           # Private application code
│   ├── api/                            # Communication Layer (Layer 3)
│   │   ├── handlers/                   # API request handlers by domain
│   │   │   ├── user/                   # User-related endpoints
│   │   │   ├── wallet/                 # Wallet-related endpoints
│   │   │   ├── auth/                   # Authentication endpoints
│   │   │   └── transaction/            # Transaction endpoints
│   │   ├── middleware/                 # Request middleware components
│   │   └── server.go                   # API server setup and configuration
│   ├── core/                           # Core/Infrastructure Layer (Layer 1)
│   │   ├── blockchain/                 # Blockchain interaction
│   │   ├── contract/                   # Smart contract interaction
│   │   ├── crypto/                     # Cryptography utilities
│   │   ├── db/                         # Database access
│   │   ├── keygen/                     # Key generation utilities
│   │   ├── keystore/                   # Key management
│   │   └── wallet/                     # Wallet operations
│   ├── services/                       # Service Layer (Layer 2)
│   │   ├── user/                       # User management domain
│   │   │   ├── model.go                # User data models
│   │   │   ├── service.go              # User service implementation
│   │   │   └── repository.go           # User data access interface and implementation
│   │   ├── wallet/                     # Wallet operations domain
│   │   │   ├── model.go                # Wallet data models
│   │   │   ├── service.go              # Wallet service implementation
│   │   │   └── repository.go           # Wallet data access interface and implementation
│   │   ├── auth/                       # Authentication domain
│   │   │   ├── model.go                # Auth data models
│   │   │   ├── service.go              # Auth service implementation
│   │   │   └── jwt.go                  # JWT token utilities
│   │   ├── blockchain/                 # Blockchain operations domain
│   │   │   ├── model.go                # Blockchain data models
│   │   │   ├── service.go              # Blockchain service implementation
│   │   │   └── client.go               # Blockchain client interactions
│   │   └── transaction/                # Transaction processing domain
│   │       ├── model.go                # Transaction data models
│   │       ├── service.go              # Transaction service implementation
│   │       └── repository.go           # Transaction data access interface and implementation
│   ├── config/                         # Configuration management
│   │   ├── config.go                   # Configuration structure and loading
│   │   └── env.go                      # Environment variable handling
│   ├── oauth2/                         # OAuth2 implementation
│   └── types/                          # Shared type definitions
│       ├── errors.go                   # Error types and constants
│       └── common.go                   # Common type definitions
├── migrations/                         # Database migrations
│   ├── 000001_create_users_table.up.sql    # Create users table migration
│   ├── 000001_create_users_table.down.sql  # Drop users table migration
│   ├── 000002_create_wallets_table.up.sql  # Create wallets table migration
│   └── 000002_create_wallets_table.down.sql # Drop wallets table migration
```

### Go Code Patterns

#### Service Pattern
```go
// Service defines the user service interface
type Service interface {
    GetUser(ctx context.Context, id string) (*User, error)
    CreateUser(ctx context.Context, user *CreateUserRequest) (*User, error)
    UpdateUser(ctx context.Context, id string, update *UpdateUserRequest) (*User, error)
    DeleteUser(ctx context.Context, id string) error
    // Other user-related operations
}

// service implements the Service interface
type service struct {
    repository Repository
    keystore   keystore.KeyStore
    // Other dependencies
}

// NewService creates a new user service
func NewService(repository Repository, keystore keystore.KeyStore) Service {
    return &service{
        repository: repository,
        keystore:   keystore,
    }
}

// Implementation of Service interface methods
func (s *service) GetUser(ctx context.Context, id string) (*User, error) {
    // Implementation
    user, err := s.repository.FindByID(ctx, id)
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }
    return user, nil
}
```

#### Models
```go
// model.go
package user

import "time"

// User represents a user entity
type User struct {
    ID        string
    Username  string
    Email     string
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

#### Repository Pattern
```go
// repository.go
package user

import (
    "context"
    "fmt"
    "vault0/internal/core/db"
)

// Repository defines the user data access interface
type Repository interface {
    FindByID(ctx context.Context, id string) (*User, error)
    FindByEmail(ctx context.Context, email string) (*User, error)
    Create(ctx context.Context, user *User) error
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id string) error
}

// repository implements Repository interface
type repository struct {
    db *db.DB
}

// NewRepository creates a new user repository
func NewRepository(db *db.DB) Repository {
    return &repository{db: db}
}

// Implementation of Repository interface methods
func (r *repository) FindByID(ctx context.Context, id string) (*User, error) {
    query := `SELECT id, username, email, created_at, updated_at FROM users WHERE id = ?`
    
    var user User
    err := r.db.ExecuteQueryRowContext(ctx, query, []interface{}{id}, &user.ID, &user.Username, &user.Email, &user.CreatedAt, &user.UpdatedAt)
    if err != nil {
        return nil, fmt.Errorf("failed to find user by ID: %w", err)
    }
    
    return &user, nil
}
```

#### DTOs and Handler Pattern
```go
// internal/api/handlers/user/dto.go
package user

// CreateUserRequest represents data needed to create a user
type CreateUserRequest struct {
    Username string `json:"username" binding:"required,min=3,max=50"`
    Email string `json:"email,omitempty" binding:"required,email"`
    Password string `json:"password" binding:"required,min=8"`
}

// UpdateUserRequest represents data for updating a user
type UpdateUserRequest struct {
    Username string `json:"username,omitempty" binding:"omitempty,min=3,max=50"`
    Email string `json:"email,omitempty" binding:"required,email"`
    Password string `json:"password,omitempty" binding:"omitempty,min=8"`
}

// UserResponse represents a user response
type UserResponse struct {
    ID        string    `json:"id"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

// ToResponse converts a user model to a user response
func ToResponse(user *user.User) *UserResponse {
    return &UserResponse{
        ID:        user.ID,
        Username:  user.Username,
        Email:     user.Email,
        CreatedAt: user.CreatedAt,
        UpdatedAt: user.UpdatedAt,
    }
}
```

#### API Handler Implementation
```go
// internal/api/handlers/user/handler.go
package user

import (
    "net/http"
    "vault0/internal/services/user"

    "github.com/gin-gonic/gin"
)

// Handler handles user-related HTTP requests
type Handler struct {
    userService user.Service
}

// NewHandler creates a new user handler
func NewHandler(userService user.Service) *Handler {
    return &Handler{
        userService: userService,
    }
}

// RegisterRoutes registers the user routes to the given router group
func (h *Handler) RegisterRoutes(router *gin.RouterGroup) {
    userRoutes := router.Group("/users")
    {
        userRoutes.GET("/:id", h.GetUser)
        userRoutes.POST("/", h.CreateUser)
        userRoutes.PUT("/:id", h.UpdateUser)
        userRoutes.DELETE("/:id", h.DeleteUser)
    }
}

// GetUser handles GET /users/:id
func (h *Handler) GetUser(c *gin.Context) {
    id := c.Param("id")
    user, err := h.userService.GetUser(c.Request.Context(), id)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user"})
        return
    }
    
    c.JSON(http.StatusOK, user)
}
```

#### Routes Configuration Pattern
```go
// internal/api/handlers/user/route.go
package user

import (
    "github.com/gin-gonic/gin"

    "vault0/internal/config"
    "vault0/internal/core/db"
    "vault0/internal/core/keystore"
    userService "vault0/internal/services/user"
)

// SetupRoutes configures all user-related routes and their dependencies
func SetupRoutes(router *gin.RouterGroup, db *db.DB, keyStore keystore.KeyStore, cfg *config.Config) {
    // Create user repository
    userRepo := userService.NewSQLiteRepository(db)

    // Create user service
    userSvc := userService.NewService(userRepo, keyStore, cfg)

    // Create user handler
    userHandler := NewHandler(userSvc)

    // Register user routes directly
    router.POST("/users", userHandler.CreateUser)
    router.GET("/users", userHandler.ListUsers)
    router.GET("/users/:id", userHandler.GetUser)
    router.PUT("/users/:id", userHandler.UpdateUser)
    router.DELETE("/users/:id", userHandler.DeleteUser)
}
```

## Next.js Development Guidelines

### Core Principles
- Follow user requirements precisely
- Plan implementation step-by-step with pseudocode
- Follow DRY (Don't Repeat Yourself) principles
- Prioritize readability over performance
- Implement all functionality completely (no TODOs)
- Include all required imports with proper component naming

### Code Style and Best Practices
- Use early returns for improved readability
- Use Tailwind classes exclusively for styling (avoid CSS or style tags)
- Prefer `class:` syntax over ternary operators in class attributes
- Use descriptive variable and function/const names
- Prefix event handlers with "handle" (e.g., "handleClick" for onClick)
- Implement proper accessibility features (tabindex, aria-label, etc.)
- Prefer const declarations over functions and define types when possible

## Smart Contract Development Guidelines

### Code Organization
- Maintain clear directory structure for contracts, tests, and deployment scripts
- Follow single responsibility principle for contract files
- Use descriptive file names
- Group related functionality together

### Development Standards
- Use latest stable Solidity version with exact pragma specification
- Always use scripts from package.json instead of direct commands
- Follow consistent contract structure:
  * State variables
  * Events
  * Modifiers
  * Constructor
  * External/public functions
  * Internal/private functions
- Implement proper access control
- Use descriptive variable and function names

### Security Guidelines
- Validate all inputs with require statements
- Implement reentrancy protection
- Use safe math operations
- Follow Checks-Effects-Interactions pattern
- Implement timelocks for critical operations
- Avoid using tx.origin for authentication
- Protect against front-running where applicable

### Testing Requirements
- Maintain minimum 90% test coverage
- Test both success and failure cases
- Include edge case testing
- Verify access control
- Test time-dependent functionality
- Validate state changes
- Test event emissions

### Documentation Standards
- Use NatSpec comments for public/external functions
- Document all events and parameters
- Explain complex logic with inline comments
- Keep documentation synchronized with code
- Document all state variables
- Include deployment parameters

### Performance Optimization
- Optimize gas usage
- Use appropriate data structures
- Minimize storage operations
- Implement batching where possible
- Use custom errors instead of strings
- Pack storage variables efficiently

### Development Workflow
- Write meaningful commit messages
- Keep pull requests focused
- Update tests with code changes
- Test on testnet before mainnet
- Verify contract source code
- Document deployment addresses

### Error Handling
- Use specific error messages
- Implement proper error recovery
- Handle edge cases
- Document error conditions
- Use standardized error patterns

### Event Logging
- Log all important state changes
- Include indexed parameters
- Use consistent naming
- Document event purposes
- Maintain event history

### Maintenance
- Keep dependencies updated
- Monitor contract performance
- Document upgrade procedures
- Maintain deployment history
- Track gas usage patterns
