---
description: NextJS
globs: ui/**/*,*.tsx,*.ts,nuxt-ui/**/*
alwaysApply: false
---
# Frontend Development Guidelines

## Overview

This document provides essential guidelines for AI agents working on the Vault0 frontend codebase, which is built with Nuxt v3. Adhering to these rules ensures consistency and maintainability.

## Technology Stack

- **Framework**: Nuxt v3
- **Language**: TypeScript
- **Styling**: TailwindCSS with shadcn/ui components located in `nuxt-ui/components/ui/`
- **State Management**: Nuxt's built-in composables with Vue's Composition API
- **Form Handling**: Vue's v-model with Zod validation
- **Authentication**: Server-side authentication with HTTP-only cookies
- **Testing**: Vitest and Vue Testing Library

## ❗ Key Rules for AI Agents ❗

1. **Package Installation Directory**: **ALWAYS** install npm packages within the `vault0/nuxt-ui` directory. Navigate using `cd nuxt-ui` **BEFORE** running `npm install <package>` or `npm add <package>`. Do **NOT** install packages at the project root (`vault0/`).

2. **API Integration**: Use the API client from plugins for server communication. Access it in your composables and components using `const { $api } = useNuxtApp()`.

3. **Model Types**: Define and use TypeScript types in the `types/` directory. Use transformation decorators where appropriate for mapping API data.

## Project Structure (`vault0/nuxt-ui`)

```
vault0/nuxt-ui/
├── .nuxt/                    # Nuxt build directory (auto-generated)
├── public/                   # Static assets
├── assets/                   # Global assets (images, fonts, etc.)
├── components/               # Vue components
│   └── ui/                   # shadcn/ui components
├── composables/              # Vue composables for reusable logic
├── layouts/                  # Page layouts
├── pages/                    # Application routes/pages
├── plugins/                  # Nuxt plugins
│   └── api/                  # API client and service modules
├── server/                   # Server-side code
├── types/                    # TypeScript type definitions
├── app.vue                   # Root Vue component
├── nuxt.config.ts            # Nuxt configuration
├── tailwind.config.js        # Tailwind CSS configuration
├── tsconfig.json             # TypeScript configuration
└── components.json           # shadcn/ui configuration
```

## Data Model Organization (`types/`)

- **Model Types**: Core type definitions in `types/*.ts` files.
- **Index**: `types/index.ts` should re-export all types for easier imports.
- **Transformation**: Use class-transformer decorators (@Expose, @Type) for API model conversion.

## API Integration (`plugins/api/` and `composables/`)

- **Client**: The base API client in `plugins/api/client.ts` handles communication with the backend.
- **Modules**: Model-specific API functions organized into separate files like `plugins/api/wallet.ts`.
- **Composables**: Wrap API calls in Vue composables (`composables/useWallets.ts`) for component use.

## Nuxt Best Practices Snippets

### API Plugin Setup

```typescript
// plugins/api/index.ts
import { defineNuxtPlugin } from '#app';
import { ApiClient } from './client';
import { WalletClient } from './wallet';
import { TransactionClient } from './transaction';

export default defineNuxtPlugin((nuxtApp) => {
  // Create the API client
  const apiClient = new ApiClient();
  
  // Get the API base URL from runtime config
  const config = useRuntimeConfig();
  apiClient.setBaseUrl(config.public.apiBase);
  
  // Create service clients
  const walletClient = new WalletClient(apiClient);
  const transactionClient = new TransactionClient(apiClient);
  
  // Provide API services to the application
  return {
    provide: {
      api: {
        wallet: walletClient,
        transaction: transactionClient
      }
    }
  };
});
```

### Composable Pattern

```typescript
// composables/useAuth.ts
export function useAuth() {
  const { $api } = useNuxtApp();
  const user = useState('user', () => null);
  const isAuthenticated = computed(() => !!user.value);
  const isLoading = ref(false);
  const error = ref(null);
  
  const login = async (email: string, password: string) => {
    isLoading.value = true;
    error.value = null;
    
    try {
      const response = await $api.auth.login({ email, password });
      user.value = response.user;
      return true;
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Login failed';
      return false;
    } finally {
      isLoading.value = false;
    }
  };
  
  const logout = async () => {
    try {
      await $api.auth.logout();
      user.value = null;
      navigateTo('/login');
    } catch (err) {
      console.error('Logout error:', err);
    }
  };
  
  return {
    user,
    isAuthenticated,
    isLoading,
    error,
    login,
    logout
  };
}
```

### Using Composables in Components

```vue
<!-- pages/login.vue -->
<script setup lang="ts">
import { z } from 'zod';

// Form validation schema
const schema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters')
});

// Form state
const form = reactive({
  email: '',
  password: ''
});

const { login, isLoading, error } = useAuth();

// Form submission
const errors = ref({});
const submitForm = async () => {
  try {
    // Validate form
    schema.parse(form);
    errors.value = {};
    
    // Submit credentials
    const success = await login(form.email, form.password);
    if (success) {
      navigateTo('/dashboard');
    }
  } catch (err) {
    if (err instanceof z.ZodError) {
      // Map validation errors
      errors.value = err.errors.reduce((acc, error) => {
        const field = error.path[0];
        acc[field] = error.message;
        return acc;
      }, {});
    }
  }
};
</script>

<template>
  <div class="flex min-h-screen items-center justify-center">
    <div class="w-full max-w-md p-6 bg-white dark:bg-gray-800 rounded-lg shadow-md">
      <h1 class="text-2xl font-bold mb-6">Login</h1>
      
      <form @submit.prevent="submitForm">
        <div class="space-y-4">
          <!-- Email field -->
          <div>
            <label for="email" class="block text-sm font-medium mb-1">Email</label>
            <input
              id="email"
              v-model="form.email"
              type="email"
              class="w-full px-3 py-2 border rounded-md"
              :class="{ 'border-red-500': errors.email }"
            />
            <p v-if="errors.email" class="mt-1 text-sm text-red-500">{{ errors.email }}</p>
          </div>
          
          <!-- Password field -->
          <div>
            <label for="password" class="block text-sm font-medium mb-1">Password</label>
            <input
              id="password"
              v-model="form.password"
              type="password"
              class="w-full px-3 py-2 border rounded-md"
              :class="{ 'border-red-500': errors.password }"
            />
            <p v-if="errors.password" class="mt-1 text-sm text-red-500">{{ errors.password }}</p>
          </div>
          
          <!-- Error message -->
          <p v-if="error" class="text-red-500">{{ error }}</p>
          
          <!-- Submit button -->
          <button
            type="submit"
            class="w-full py-2 px-4 bg-primary text-white rounded-md"
            :disabled="isLoading"
          >
            {{ isLoading ? 'Logging in...' : 'Login' }}
          </button>
        </div>
      </form>
    </div>
  </div>
</template>
```

### API Client Structure

```typescript
// plugins/api/client.ts
export class ApiClient {
  private baseUrl: string;
  private token: string | undefined;

  constructor(token?: string, baseUrl?: string) {
    this.baseUrl = baseUrl || '';
    this.token = token;
  }

  setBaseUrl(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  setToken(token: string) {
    this.token = token;
  }

  async request<T>(path: string, options: ApiRequestOptions = {}): Promise<T> {
    const { method = 'GET', body, params, headers = {} } = options;
    
    // Prepare headers
    const requestHeaders: Record<string, string> = { 
      ...headers as Record<string, string>,
      'Content-Type': 'application/json'
    };
    
    if (this.token) {
      requestHeaders['Authorization'] = `Bearer ${this.token}`;
    }
    
    try {
      // Use Nuxt's $fetch utility
      return await $fetch<T>(path, {
        baseURL: this.baseUrl,
        method,
        body: method !== 'GET' ? body : undefined,
        params,
        headers: requestHeaders
      });
    } catch (error: any) {
      // Handle errors
      if (error.name === 'FetchError') {
        const apiError = error.data as ApiError;
        throw new Error(apiError?.message || error.message || `API Error: ${error.status}`);
      }
      
      throw error;
    }
  }

  // HTTP method convenience wrappers
  get<T>(path: string, params?: Record<string, string | number | boolean>): Promise<T> {
    return this.request<T>(path, { method: 'GET', params });
  }

  post<T>(path: string, body?: any): Promise<T> {
    return this.request<T>(path, { method: 'POST', body });
  }

  // Additional methods: put, patch, delete...
}
```

### Type Definition with Transformation

```typescript
// types/wallet.ts
import { Expose, Type } from 'class-transformer';
import { BaseModel } from './model';

export class Wallet extends BaseModel {
  @Expose()
  id!: number;
  
  @Expose({ name: 'chain_type' })
  chainType!: string;
  
  @Expose()
  address!: string;
  
  @Expose()
  name!: string;
  
  @Expose()
  tags?: Record<string, string>;
  
  @Expose({ name: 'created_at' })
  createdAt!: string;
  
  constructor(data: Partial<Wallet> = {}) {
    super();
    Object.assign(this, data);
  }

  static fromJson(json: any): Wallet {
    return fromJson(Wallet, json);
  }
}
```

## shadcn/ui Integration

shadcn/ui components are installed in the `components/ui/` directory. These components are built with TailwindCSS and provide a consistent design system.

### Using shadcn/ui Components

```vue
<!-- components/WalletCard.vue -->
<script setup lang="ts">
import { Wallet } from '~/types/wallet';

defineProps<{
  wallet: Wallet;
}>();

const emit = defineEmits<{
  edit: [wallet: Wallet];
  delete: [wallet: Wallet];
}>();
</script>

<template>
  <Card class="mb-4">
    <CardHeader>
      <CardTitle>{{ wallet.name }}</CardTitle>
      <CardDescription>{{ wallet.chainType }}</CardDescription>
    </CardHeader>
    
    <CardContent>
      <p class="font-mono text-sm">{{ wallet.address }}</p>
      
      <div v-if="wallet.tags" class="mt-4">
        <div v-for="(value, key) in wallet.tags" :key="key" class="inline-flex items-center mr-2 mb-2">
          <Badge variant="outline">{{ key }}: {{ value }}</Badge>
        </div>
      </div>
    </CardContent>
    
    <CardFooter class="flex justify-end space-x-2">
      <Button variant="outline" size="sm" @click="emit('edit', wallet)">
        Edit
      </Button>
      <Button variant="destructive" size="sm" @click="emit('delete', wallet)">
        Delete
      </Button>
    </CardFooter>
  </Card>
</template>
```

## General Guidelines

- **Indentation**: Use **2 spaces** for indentation. DO NOT USE TABS.
- **File names**: Use *camelCase* for file names.
- **Component names**: Use *PascalCase* for component names in both file names and component definitions.
- **Follow Existing Patterns**: Mimic the style and structure of existing code in the module you are editing.
- **TypeScript**: Use TypeScript effectively. Define types and interfaces, leverage generics, and avoid `any` where possible.
- **Components**: Utilize shadcn/ui components from `components/ui` for consistency. Keep custom components small, focused, and reusable.
- **Clarity**: Write clear, concise, and well-commented code, especially for complex logic.
- **Error Handling**: Implement robust error handling in API calls and component logic.
- **Accessibility**: Keep accessibility in mind when creating UI elements. 