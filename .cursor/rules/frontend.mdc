---
description: NextJS
globs: ui/**/*,*.tsx,*.ts
alwaysApply: false
---
# AI Agent Guidelines: Vault0 Frontend (Remix.js)

## Overview

This document provides essential guidelines for AI agents working on the Vault0 frontend codebase, which is built with Remix.js. Adhering to these rules ensures consistency and maintainability.

## Technology Stack

- **Framework**: Remix.js
- **Language**: TypeScript
- **Styling**: TailwindCSS with shadcn/ui components located in `ui/app/components/ui/`
- **State Management**: Remix's built-in data loading + React Context API
- **Form Handling**: Remix's FormData API with Zod validation
- **Authentication**: Server-side authentication with HTTP-only cookies
- **Testing**: Vitest and React Testing Library

## ❗ Key Rules for AI Agents ❗

1.  **Package Installation Directory**: **ALWAYS** install npm packages within the `vault0/ui` directory. Navigate using `cd ui` **BEFORE** running `npm install <package>` or `npm add <package>`. Do **NOT** install packages at the project root (`vault0/`).
2.  **Response Helper**: **ALWAYS** use `Response.json()` to return JSON data from Remix loaders and actions. **NEVER** use the `json()` helper function imported from `@remix-run/node`.

    ```typescript
    // Correct way in loaders/actions:
    import type { LoaderFunctionArgs } from "@remix-run/node";
    import { getSomeData } from "~/server/api/some.server"; // Example import

    export const loader = async ({ request }: LoaderFunctionArgs) => {
      // ... authentication, data fetching ...
      const data = await getSomeData();
      // Use Response.json() directly. Status 200 and correct Content-Type are defaults.
      return Response.json({ data }); 
    };
    
    // Incorrect way (❌ DO NOT USE ❌):
    // import { json } from "@remix-run/node"; // Do not import this
    // return json(data); // Do not use this function
    
    // Also avoid manual stringification unless absolutely necessary:
    // return new Response(JSON.stringify(data), { headers: { "Content-Type": "application/json" } });
    ```
3.  **Error Responses**: For error responses, you can use `Response.json()` to return structured error details (e.g., validation errors) or the `Response` constructor for simple text errors.

    ```typescript
    // Example: Returning structured validation errors
    if (!validation.success) {
      return Response.json({ errors: validation.error.issues }, { status: 400 });
    }
    
    // Example: Returning a simple error message
    catch (error) {
        console.error("Operation failed:", error);
        return new Response("Something went wrong", { status: 500 });
    }
    ```

## Project Structure (`vault0/ui`)

```
vault0/ui/
├── public/                  # Static assets
├── app/
│   ├── components/          # React components (includes ui/, common/, forms/, model-specific)
│   │   └── ui/              # shadcn/ui components reside here
│   ├── hooks/               # Custom React hooks
│   ├── lib/                 # Utility functions and constants
│   ├── models/              # Data models (types/, schemas/)
│   ├── routes/              # Remix routes (including nested and api/ routes)
│   ├── server/              # Server-side code (api/, auth.server.ts, session.server.ts)
│   ├── styles/              # Global styles (tailwind.css)
│   ├── root.tsx             # Root layout
│   ├── entry.client.tsx     # Client entry point
│   └── entry.server.tsx     # Server entry point
├── tailwind.config.ts       # Tailwind CSS configuration
├── tsconfig.json            # TypeScript configuration
└── vite.config.ts           # Vite configuration
```
*(Structure confirmed on 2024-07-27 - Re-verify if significant changes occur)*

## Data Model Organization (`app/models`)

- **Types**: Core type definitions are in `app/models/types/*.types.ts`.
- **Schemas**: Zod validation schemas are in `app/models/schemas/*.schema.ts`.
- **Index**: `app/models/index.ts` re-exports all types and schemas for easier import.

## API Integration (`app/server/api`)

- **Client**: A base `apiRequest` function often exists (verify `app/server/api/client.ts`) for making backend calls.
- **Modules**: Model-specific API functions (e.g., `listVaults`, `createWallet`) are organized into separate files like `app/server/api/vault.server.ts` and `app/server/api/wallet.server.ts`.
- **Usage**: Use these server API modules within Remix loaders and actions located in the `app/routes/` directory.

## Remix Best Practices Snippets

### Loader Function Example

```typescript
// Example: app/routes/dashboard.some-feature.tsx
import type { LoaderFunctionArgs } from "@remix-run/node"; // Use LoaderFunctionArgs
import { requireUserId, getToken } from "~/server/session.server"; // Authentication helpers
import { listSomething } from "~/server/api/something.server"; // API call
import type { Something } from "~/models"; // Data type

// Define expected data shape
type LoaderData = {
  items: Something[];
};

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const userId = await requireUserId(request); // Enforce authentication
  const token = await getToken(request);       // Get token for API call

  try {
    const items = await listSomething(userId, token);
    const data: LoaderData = { items };
    // ✅ Use Response.json()
    return Response.json(data); 
  } catch (error) {
    console.error("Failed to load items:", error);
    // Use Response constructor for simple error text
    return new Response("Error fetching data", { status: 500 });
  }
};

// ... component using useLoaderData<typeof loader> ...
```

### Action Function Example (Form Handling)

```typescript
// Example: app/routes/dashboard.some-feature.new.tsx
import type { ActionFunctionArgs } from "@remix-run/node";
import { redirect } from "@remix-run/node"; // Use for successful redirects
import { Form, useActionData } from "@remix-run/react"; // Remix form utilities
import { z } from "zod"; // For validation
import { requireUserId, getToken } from "~/server/session.server"; // Authentication
import { createSomething } from "~/server/api/something.server"; // API call
import { Button } from "~/components/ui/button"; // shadcn/ui component
import { Input } from "~/components/ui/input"; // shadcn/ui component
import { SomeFeatureSchema } from "~/models"; // Zod schema import

// Define possible action responses (e.g., errors)
type ActionResponse = {
  errors?: z.ZodIssue[]; // Validation errors
  message?: string;      // General error message
};

export const action = async ({ request }: ActionFunctionArgs) => {
  const userId = await requireUserId(request);
  const token = await getToken(request);
  const formData = await request.formData();
  const rawData = Object.fromEntries(formData);

  // Validate form data
  const validation = SomeFeatureSchema.safeParse(rawData);

  if (!validation.success) {
    const responseData: ActionResponse = { errors: validation.error.issues };
    // ✅ Use Response.json() for structured error data
    return Response.json(responseData, { status: 400 }); 
  }

  try {
    // Perform action on successful validation
    await createSomething({ ...validation.data, userId }, token);
    // Redirect on success
    return redirect("/dashboard/some-feature"); 
  } catch (error: any) {
    console.error("Failed to create item:", error);
    const responseData: ActionResponse = { message: error.message || "Failed to create item." };
    // ✅ Use Response.json() for structured error data
    return Response.json(responseData, { status: 500 });
  }
};

// ... component using <Form method="post"> and useActionData<typeof action> ...
```

### Authentication & Session (`app/server/session.server.ts`)

- Use `requireUserId(request)` in loaders/actions to protect routes that require login.
- Use `getUserId(request)` to optionally get the user ID (returns `null` if not logged in).
- Use `getToken(request)` to retrieve the auth token needed for backend API calls.
- Use `createUserSession` (likely found in `auth.server.ts` or similar) after successful user login.

## General Guidelines

- **Follow Existing Patterns**: Mimic the style and structure of existing code in the module you are editing.
- **TypeScript**: Use TypeScript effectively. Define types and interfaces, leverage generics, and avoid `any` where possible.
- **Components**: Utilize `shadcn/ui` components from `~/components/ui` for consistency. Keep custom components small, focused, and reusable.
- **Clarity**: Write clear, concise, and well-commented code, especially for complex logic.
- **Error Handling**: Implement robust error handling in loaders, actions, and component logic.
- **Accessibility**: Keep accessibility in mind when creating UI elements. 