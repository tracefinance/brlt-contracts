---
description: NextJS
globs: ui/**/*,*.ts,*.vue
alwaysApply: false
---
# Frontend Development Guidelines

## Overview

This document provides essential guidelines for AI agents working on the Vault0 frontend codebase, which is built with Nuxt v3. Adhering to these rules ensures consistency and maintainability.

## Technology Stack

- **Framework**: Nuxt v3
- **Language**: TypeScript
- **Styling**: TailwindCSS with shadcn/ui components located in `nuxt-ui/components/ui/`
- **State Management**: Nuxt\'s built-in composables with Vue\'s Composition API
- **Form Handling**: Vue\'s v-model with Zod validation
- **Authentication**: Server-side authentication with HTTP-only cookies
- **Testing**: Vitest and Vue Testing Library

## ❗ Key Rules for AI Agents ❗

1. **Package Installation Directory**: **ALWAYS** install npm packages within the `vault0/ui` directory. Navigate using `cd ui` **BEFORE** running `npm install <package>` or `npm add <package>`. Do **NOT** install packages at the project root (`vault0/`).

2. **API Integration**: Use the API client from plugins for server communication. Access it in your composables and components using `const { $api } = useNuxtApp()`.

3. **Model Types**: Define and use TypeScript interfaces in the `types/` directory. Use helper functions and factory objects for mapping API data (snake_case) to frontend types (camelCase).

## Project Structure (`vault0/ui`)

```
vault0/ui/
├── .nuxt/                    # Nuxt build directory (auto-generated)
├── public/                   # Static assets
├── assets/                   # Global assets (images, fonts, etc.)
├── components/               # Vue components
│   └── ui/                   # shadcn/ui components
├── composables/              # Vue composables for reusable logic
├── layouts/                  # Page layouts
├── pages/                    # Application routes/pages
├── plugins/                  # Nuxt plugins
│   └── api/                  # API client and service modules
├── server/                   # Server-side code
├── types/                    # TypeScript type definitions
├── app.vue                   # Root Vue component
├── nuxt.config.ts            # Nuxt configuration
├── tailwind.config.js        # Tailwind CSS configuration
├── tsconfig.json             # TypeScript configuration
└── components.json           # shadcn/ui configuration
```

## Data Model Organization (`types/`)

- **Model Types**: Core type definitions as interfaces (`IModel`) in `types/*.ts` files.
- **Index**: `types/index.ts` should re-export all types for easier imports.
- **Transformation**: Use helper functions (`fromJson`, `fromJsonArray` from `types/model.ts`) within factory objects (`Model`) associated with each interface to convert snake_case API responses to camelCase TypeScript interfaces. See the example below.

## API Integration (`plugins/api/` and `composables/`)

- **Client**: The base API client in `plugins/api/client.ts` handles communication with the backend.
- **Modules**: Model-specific API functions organized into separate files like `plugins/api/wallet.ts`.
- **Composables**: Wrap API calls in Vue composables (`composables/useWallets.ts`) for component use.

## Nuxt Best Practices Snippets

### API Plugin Setup

```typescript
// plugins/api/index.ts
import { defineNuxtPlugin } from '#app';
import { ApiClient } from './client';
import { WalletClient } from './wallet';
import { TransactionClient } from './transaction';

export default defineNuxtPlugin((nuxtApp) => {
  // Create the API client
  const apiClient = new ApiClient();
  
  // Get the API base URL from runtime config
  const config = useRuntimeConfig();
  apiClient.setBaseUrl(config.public.apiBase);
  
  // Create service clients
  const walletClient = new WalletClient(apiClient);
  const transactionClient = new TransactionClient(apiClient);
  
  // Provide API services to the application
  return {
    provide: {
      api: {
        wallet: walletClient,
        transaction: transactionClient
      }
    }
  };
});
```

### Composable Pattern (Data Fetching with `useAsyncData`)

Use Nuxt's `useAsyncData` for fetching data within composables. It simplifies handling loading states, errors, and reactivity.

```typescript
// composables/useWallets.ts
import { IWallet, PagedWallets } from '~/types'; // Assuming PagedWallets type exists

export function useWallets(limit: Ref<number>, offset: Ref<number>) {
  const { $api } = useNuxtApp();

  const { 
    data: walletsData, 
    status, // 'idle', 'pending', 'success', 'error'
    error, 
    refresh // Function to manually trigger a refetch
  } = useAsyncData<IPagedWallets>(
    'wallets', // Unique key for the data
    () => $api.wallet.getWallets(limit.value, offset.value), // API call
    {
      watch: [limit, offset], // Automatically refetch when limit or offset changes
      // transform: (data) => data.items, // Optional: Transform data before returning
      // default: () => ({ items: [], limit: 10, offset: 0, hasMore: false }) // Optional: Provide default value
    }
  );

  // Computed properties for easier access in components
  const wallets = computed(() => walletsData.value?.items || []);
  const hasMore = computed(() => walletsData.value?.hasMore || false);
  const isLoading = computed(() => status.value === 'pending');

  return {
    wallets,
    hasMore,
    isLoading,
    error,
    refresh, // Expose refresh function if manual refetching is needed
  };
}
```

### Using Composables in Components

Components can directly use these composables to access data, loading states, and error information.

```vue
<!-- pages/wallets/index.vue -->
<script setup lang="ts">
import { ref, computed } from 'vue';
import { useWallets } from '~/composables/useWallets';

// Pagination state
const limit = ref(10);
const offset = ref(0);

// Use the composable to fetch wallets
const { wallets, hasMore, isLoading, error, refresh } = useWallets(limit, offset);

// Pagination handlers (simplified)
function nextPage() {
  if (hasMore.value) {
    offset.value += limit.value;
  }
}

function prevPage() {
  offset.value = Math.max(0, offset.value - limit.value);
}

function handleLimitChange(newLimit: number) {
  limit.value = newLimit;
  offset.value = 0; // Reset offset when limit changes
}

</script>

<template>
  <div>
    <h1>My Wallets</h1>

    <div v-if="isLoading" class="p-4">
      Loading wallets...
    </div>

    <div v-else-if="error" class="p-4 bg-red-50 text-red-700 rounded-md">
      Error loading wallets: {{ error.message }}
      <button @click="refresh">Retry</button>
    </div>

    <div v-else-if="wallets.length === 0" class="p-4 text-muted-foreground">
      No wallets found.
    </div>

    <div v-else>
      <!-- List Wallets -->
      <div v-for="wallet in wallets" :key="wallet.id" class="border-b p-4">
        <p><strong>Name:</strong> {{ wallet.name }}</p>
        <p><strong>Address:</strong> {{ wallet.address }}</p>
        <p><strong>Chain:</strong> {{ wallet.chainType }}</p>
      </div>

      <!-- Pagination Controls -->
      <div class="flex items-center gap-2 mt-4 p-4">
        <PaginationSizeSelect :current-limit="limit" @update:limit="handleLimitChange" />
        <PaginationControls 
          :offset="offset" 
          :limit="limit" 
          :has-more="hasMore" 
          @previous="prevPage"
          @next="nextPage"
        />
      </div>
    </div>

  </div>
</template>
```

### API Client Structure

```typescript
// plugins/api/client.ts
export class ApiClient {
  private baseUrl: string;
  private token: string | undefined;

  constructor(token?: string, baseUrl?: string) {
    this.baseUrl = baseUrl || '';
    this.token = token;
  }

  setBaseUrl(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  setToken(token: string) {
    this.token = token;
  }

  async request<T>(path: string, options: ApiRequestOptions = {}): Promise<T> {
    const { method = 'GET', body, params, headers = {} } = options;
    
    // Prepare headers
    const requestHeaders: Record<string, string> = { 
      ...headers as Record<string, string>,
      'Content-Type': 'application/json'
    };
    
    if (this.token) {
      requestHeaders['Authorization'] = \`Bearer \${this.token}\`;
    }
    
    try {
      // Use Nuxt's $fetch utility
      return await $fetch<T>(path, {
        baseURL: this.baseUrl,
        method,
        body: method !== 'GET' ? body : undefined,
        params,
        headers: requestHeaders
      });
    } catch (error: any) {
      // Handle errors
      if (error.name === 'FetchError') {
        const apiError = error.data as ApiError;
        throw new Error(apiError?.message || error.message || \`API Error: \${error.status}\`);
      }
      
      throw error;
    }
  }

  // HTTP method convenience wrappers
  get<T>(path: string, params?: Record<string, string | number | boolean>): Promise<T> {
    return this.request<T>(path, { method: 'GET', params });
  }

  post<T>(path: string, body?: any): Promise<T> {
    return this.request<T>(path, { method: 'POST', body });
  }

  // Additional methods: put, patch, delete...
}
```

### Type Definition with Transformation

```typescript
// types/wallet.ts
import { fromJson, fromJsonArray } from './model'; // Import helper functions

/**
 * Interface representing a wallet
 */
export interface IWallet {
  id: number;
  keyId: string;       // Mapped from API's snake_case key_id
  chainType: string;   // Mapped from API's snake_case chain_type
  address: string;
  name: string;
  tags?: Record<string, string>;
  lastBlockNumber?: number; // Mapped from API's snake_case last_block_number
  createdAt: string;     // Mapped from API's snake_case created_at
  updatedAt: string;     // Mapped from API's snake_case updated_at
}

/**
 * Factory functions for IWallet
 */
export const Wallet = {
  /**
   * Converts a plain JSON object (snake_case) from the API to an IWallet (camelCase)
   */
  fromJson(json: any): IWallet {
    return fromJson<IWallet>(json); // Use the generic helper
  },

  /**
   * Converts an array of plain JSON objects from the API to IWallet objects
   */
  fromJsonArray(jsonArray: any[]): IWallet[] {
    return fromJsonArray<IWallet>(jsonArray); // Use the generic helper
  }
};

// Example usage:
// const apiResponse = { id: 1, key_id: 'abc', chain_type: 'ETH', ... };
// const wallet: IWallet = Wallet.fromJson(apiResponse);
// console.log(wallet.keyId); // Output: abc
```

## shadcn/ui Integration

shadcn/ui components are installed in the `components/ui/` directory. These components are built with TailwindCSS and provide a consistent design system.

### Using shadcn/ui Components

```vue
<!-- components/WalletCard.vue -->
<script setup lang="ts">
import { IWallet } from '~/types/wallet';

defineProps<{
  wallet: IWallet;
}>();

const emit = defineEmits<{
  edit: [wallet: IWallet];
  delete: [wallet: IWallet];
}>();
</script>

<template>
  <Card class="mb-4">
    <CardHeader>
      <CardTitle>{{ wallet.name }}</CardTitle>
      <CardDescription>{{ wallet.chainType }}</CardDescription>
    </CardHeader>
    
    <CardContent>
      <p class="font-mono text-sm">{{ wallet.address }}</p>
      
      <div v-if="wallet.tags" class="mt-4">
        <div v-for="(value, key) in wallet.tags" :key="key" class="inline-flex items-center mr-2 mb-2">
          <Badge variant="outline">{{ key }}: {{ value }}</Badge>
        </div>
      </div>
    </CardContent>
    
    <CardFooter class="flex justify-end space-x-2">
      <Button variant="outline" size="sm" @click="emit('edit', wallet)">
        Edit
      </Button>
      <Button variant="destructive" size="sm" @click="emit('delete', wallet)">
        Delete
      </Button>
    </CardFooter>
  </Card>
</template>
```

## General Guidelines

- **Indentation**: Use **2 spaces** for indentation. DO NOT USE TABS.
- **File names**: Use *camelCase* for file names.
- **Component names**: Use *PascalCase* for component names in both file names and component definitions.
- **Follow Existing Patterns**: Mimic the style and structure of existing code in the module you are editing.
- **TypeScript**: Use TypeScript effectively. Define types and interfaces, leverage generics, and avoid `any` where possible.
- **Components**: Utilize shadcn/ui components from `components/ui` for consistency. Keep custom components small, focused, and reusable.
- **Clarity**: Write clear, concise, and well-commented code, especially for complex logic.
- **Error Handling**: Implement robust error handling in API calls and component logic.
- **Accessibility**: Keep accessibility in mind when creating UI elements. 