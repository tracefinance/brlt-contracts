---
description: NextJS
globs: ui/**/*,*.tsx,*.ts
alwaysApply: false
---
# Vault0 Frontend Architecture

## Overview

The Vault0 frontend is built with Next.js 15, leveraging the App Router architecture for a modern, type-safe, and performant web application. The frontend connects to REST APIs and incorporates Web3 functionality to interact with blockchain technologies, all while maintaining a clean separation of concerns.

## Technology Stack

- **Framework**: Next.js 15
- **Language**: TypeScript
- **Styling**: TailwindCSS with shadcn/ui components
- **State Management**: React Context API and React Query
- **Form Handling**: React Hook Form with Zod validation
- **Web3 Integration**: Custom hooks for blockchain interactions
- **Authentication**: JWT-based auth with secure HTTP-only cookies
- **Testing**: Jest and React Testing Library

## Project Structure

```
vault0/ui/
├── public/                  # Static assets
├── src/
│   ├── app/                 # App Router pages and layouts
│   │   ├── (auth)/          # Auth-related route group
│   │   │   ├── login/       # Login page route
│   │   │   └── signup/      # Signup page route
│   │   ├── dashboard/       # Dashboard route
│   │   │   ├── vaults/      # Vaults management
│   │   │   │   └── [id]/    # Dynamic route for specific vault
│   │   │   └── settings/    # User settings
│   │   ├── api/             # API routes (if needed)
│   │   ├── layout.tsx       # Root layout
│   │   └── page.tsx         # Homepage
│   ├── components/          # React components
│   │   ├── ui/              # Base UI components (shadcn/ui)
│   │   ├── common/          # Shared components
│   │   │   ├── Header.tsx
│   │   │   ├── Footer.tsx
│   │   │   └── ...
│   │   ├── forms/           # Form components
│   │   │   ├── LoginForm.tsx
│   │   │   └── ...
│   │   ├── vaults/          # Vault-specific components
│   │   └── web3/            # Blockchain-related components
│   ├── hooks/               # Custom React hooks
│   │   ├── api/             # API interaction hooks
│   │   │   ├── useVaults.ts
│   │   │   └── ...
│   │   ├── auth/            # Authentication hooks
│   │   │   ├── useAuth.ts
│   │   │   └── ...
│   │   └── web3/            # Blockchain hooks
│   │       ├── useWallet.ts
│   │       └── ...
│   ├── lib/                 # Utility functions and services
│   │   ├── api/             # API client
│   │   │   ├── client.ts    # Axios instance setup
│   │   │   ├── endpoints.ts # API endpoint definitions
│   │   │   └── types.ts     # API types
│   │   ├── utils/           # Helper functions
│   │   ├── web3/            # Web3 utilities
│   │   └── constants.ts     # Application constants
│   ├── types/               # TypeScript type definitions
│   │   ├── api.ts           # API response/request types
│   │   ├── vault.ts         # Vault-related types
│   │   └── web3.ts          # Blockchain-related types
│   └── providers/           # Context providers
│       ├── AuthProvider.tsx # Authentication context
│       └── Web3Provider.tsx # Web3 context
├── next.config.ts           # Next.js configuration
├── tsconfig.json            # TypeScript configuration
├── tailwind.config.js       # Tailwind CSS configuration
└── .nvmrc                   # Node version
```

## Architecture Layers

### 1. Presentation Layer
- **Components**: Reusable UI building blocks
- **Pages**: Routing and page layouts
- **Layouts**: Shared layout structures

### 2. Application Layer
- **Hooks**: Business logic and state management
- **Providers**: Context providers for global state
- **Forms**: Form handling and validation

### 3. Data Access Layer
- **API Client**: REST API communication
- **Web3 Client**: Blockchain interaction
- **Data Hooks**: Data fetching and caching

### 4. Infrastructure Layer
- **Configuration**: Environment and app settings
- **Utils**: Shared utilities and helpers
- **Types**: Type definitions for type safety

## Development Setup

### Prerequisites
- Node.js 20.x or higher (see `.nvmrc`)
- npm or yarn
- Git

### Getting Started

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd vault0
   ```

2. **Install dependencies**
   ```bash
   cd ui
   npm install
   ```

3. **Set up environment variables**
   
   Create a `.env.local` file in the `ui` directory:
   ```
   NEXT_PUBLIC_API_URL=http://localhost:8080/api
   NEXT_PUBLIC_CHAIN_ID=1
   NEXT_PUBLIC_RPC_URL=https://mainnet.infura.io/v3/your-infura-key
   ```

4. **Start the development server**
   ```bash
   npm run dev
   ```
   
   The application will be available at `http://localhost:3000`

## Key Implementation Patterns

### API Client

The API client uses Axios for HTTP requests and implements interceptors for authentication and error handling:

```typescript
// src/lib/api/client.ts
import axios, { AxiosError } from 'axios';
import { toast } from 'sonner';

const API_URL = process.env.NEXT_PUBLIC_API_URL;

export const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  withCredentials: true, // Important for cookies
});

// Request interceptor for auth
apiClient.interceptors.request.use(
  (config) => {
    // Add any request modifications here
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor for error handling
apiClient.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    const status = error.response?.status;
    
    // Handle authentication errors
    if (status === 401) {
      toast.error('Session expired. Please log in again.');
      // Redirect to login if needed
    }
    
    // Handle server errors
    if (status && status >= 500) {
      toast.error('Server error. Please try again later.');
    }
    
    return Promise.reject(error);
  }
);
```

### Data Fetching with React Query

React Query is used for data fetching, caching, and state management:

```typescript
// src/hooks/api/useVaults.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/lib/api/client';
import { Vault } from '@/types/vault';

// Fetch all vaults
export function useVaults() {
  return useQuery({
    queryKey: ['vaults'],
    queryFn: async (): Promise<Vault[]> => {
      const { data } = await apiClient.get('/vaults');
      return data;
    }
  });
}

// Fetch a single vault by ID
export function useVault(id: string) {
  return useQuery({
    queryKey: ['vaults', id],
    queryFn: async (): Promise<Vault> => {
      const { data } = await apiClient.get(`/vaults/${id}`);
      return data;
    },
    enabled: !!id
  });
}

// Create a new vault
export function useCreateVault() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (newVault: Partial<Vault>): Promise<Vault> => {
      const { data } = await apiClient.post('/vaults', newVault);
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['vaults'] });
    }
  });
}
```

### Authentication with Context API

Authentication state is managed via React Context API:

```typescript
// src/providers/AuthProvider.tsx
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import { apiClient } from '@/lib/api/client';
import { User } from '@/types/api';

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data } = await apiClient.get('/auth/me');
        setUser(data);
      } catch (error) {
        setUser(null);
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();
  }, []);

  const login = async (email: string, password: string) => {
    setIsLoading(true);
    try {
      const { data } = await apiClient.post('/auth/login', { email, password });
      setUser(data.user);
      router.push('/dashboard');
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    try {
      await apiClient.post('/auth/logout');
      setUser(null);
      router.push('/login');
    } catch (error) {
      console.error('Logout failed', error);
    }
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        login,
        logout,
        isAuthenticated: !!user,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
```

### Web3 Integration

Custom hooks for Web3 interactions:

```typescript
// src/hooks/web3/useWallet.ts
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';

export function useWallet() {
  const [account, setAccount] = useState<string | null>(null);
  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);
  const [isConnecting, setIsConnecting] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  // Check if wallet is already connected
  useEffect(() => {
    const checkConnection = async () => {
      if (typeof window.ethereum !== 'undefined') {
        try {
          const ethProvider = new ethers.BrowserProvider(window.ethereum);
          const accounts = await ethProvider.listAccounts();
          
          if (accounts.length > 0) {
            setAccount(accounts[0].address);
            setProvider(ethProvider);
          }
        } catch (err) {
          console.error('Failed to connect to wallet', err);
        }
      }
    };

    checkConnection();
  }, []);

  // Connect wallet function
  const connect = async () => {
    if (typeof window.ethereum === 'undefined') {
      setError(new Error('MetaMask is not installed'));
      return;
    }

    setIsConnecting(true);
    setError(null);

    try {
      const ethProvider = new ethers.BrowserProvider(window.ethereum);
      const accounts = await ethProvider.send('eth_requestAccounts', []);
      
      if (accounts.length > 0) {
        setAccount(accounts[0]);
        setProvider(ethProvider);
      }
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to connect wallet'));
    } finally {
      setIsConnecting(false);
    }
  };

  return {
    account,
    provider,
    isConnecting,
    error,
    connect,
  };
}
```

### Server Components vs. Client Components

Next.js 15 follows the React Server Components paradigm. Here's how we structure components:

- **Server Components**: Used for data fetching, SEO, and static parts
- **Client Components**: Used for interactivity, state, and effects

Example of a Server Component:

```typescript
// src/app/dashboard/vaults/page.tsx
import { Suspense } from 'react';
import { VaultsList } from '@/components/vaults/VaultsList';
import { VaultsSkeletonList } from '@/components/vaults/VaultsSkeletonList';
import { getVaults } from '@/lib/api/serverActions';

export const metadata = {
  title: 'Your Vaults | Vault0',
  description: 'Manage your secure vaults',
};

export default async function VaultsPage() {
  // Data fetching happens on the server
  const vaults = await getVaults();
  
  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-6">Your Vaults</h1>
      
      <Suspense fallback={<VaultsSkeletonList />}>
        <VaultsList initialVaults={vaults} />
      </Suspense>
    </div>
  );
}
```

Example of a Client Component:

```typescript
// src/components/vaults/CreateVaultButton.tsx
'use client'; // Mark as client component

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { useCreateVault } from '@/hooks/api/useVaults';
import { toast } from 'sonner';

export function CreateVaultButton() {
  const [isOpen, setIsOpen] = useState(false);
  const createVault = useCreateVault();
  
  const handleCreate = async (formData) => {
    try {
      await createVault.mutateAsync(formData);
      setIsOpen(false);
      toast.success('Vault created successfully');
    } catch (error) {
      toast.error('Failed to create vault');
    }
  };
  
  return (
    <>
      <Button onClick={() => setIsOpen(true)}>
        Create New Vault
      </Button>
      
      {/* Modal implementation */}
    </>
  );
}
```

## Routing and Navigation

Next.js 15 App Router uses file-based routing with support for:

- **Static Routes**: Fixed URL paths
- **Dynamic Routes**: URL paths with parameters
- **Route Groups**: Logical grouping without affecting the URL
- **Parallel Routes**: Multiple views on the same page
- **Intercepting Routes**: Modal-based interactions

Example routing structure:

```
app/
├── layout.tsx                # Root layout
├── page.tsx                  # Home page (/)
├── (auth)/                   # Route group (doesn't affect URL)
│   ├── login/                # /login
│   │   └── page.tsx
│   └── signup/               # /signup
│       └── page.tsx
├── dashboard/                # /dashboard
│   ├── layout.tsx            # Dashboard layout
│   ├── page.tsx              # Dashboard index
│   ├── vaults/               # /dashboard/vaults
│   │   ├── page.tsx          # Vaults list
│   │   └── [id]/             # /dashboard/vaults/123
│   │       ├── page.tsx      # View vault
│   │       └── edit/         # /dashboard/vaults/123/edit
│   │           └── page.tsx  # Edit vault
│   └── settings/             # /dashboard/settings
│       └── page.tsx          # User settings
└── api/                      # API routes (if needed)
    └── webhooks/
        └── route.ts          # API endpoint handler
```

## Styling Approach

Vault0 uses TailwindCSS with the shadcn/ui component library:

```typescript
// src/components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
```

## Testing Strategy

Vault0 implements comprehensive testing using Jest and React Testing Library:

```typescript
// src/components/forms/LoginForm.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { LoginForm } from './LoginForm';
import { AuthProvider } from '@/providers/AuthProvider';
import { mockLogin } from '@/mocks/auth';

jest.mock('@/lib/api/client', () => ({
  apiClient: {
    post: jest.fn(),
  },
}));

describe('LoginForm', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders the login form', () => {
    render(
      <AuthProvider>
        <LoginForm />
      </AuthProvider>
    );

    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /sign in/i })).toBeInTheDocument();
  });

  it('validates form inputs', async () => {
    render(
      <AuthProvider>
        <LoginForm />
      </AuthProvider>
    );

    const submitButton = screen.getByRole('button', { name: /sign in/i });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText(/email is required/i)).toBeInTheDocument();
      expect(screen.getByText(/password is required/i)).toBeInTheDocument();
    });
  });

  it('submits the form with valid data', async () => {
    mockLogin.mockResolvedValueOnce({ user: { id: '1', email: 'test@example.com' } });

    render(
      <AuthProvider>
        <LoginForm />
      </AuthProvider>
    );

    fireEvent.change(screen.getByLabelText(/email/i), {
      target: { value: 'test@example.com' },
    });
    fireEvent.change(screen.getByLabelText(/password/i), {
      target: { value: 'password123' },
    });
    fireEvent.click(screen.getByRole('button', { name: /sign in/i }));

    await waitFor(() => {
      expect(mockLogin).toHaveBeenCalledWith({
        email: 'test@example.com',
        password: 'password123',
      });
    });
  });
});
```

## Performance Optimization

- **Image Optimization**: Using Next.js Image component
- **Font Optimization**: Using Next.js Font system
- **Code Splitting**: Automatic code splitting
- **Server Components**: Reduce client-side JavaScript
- **Caching**: Leveraging React Query's caching capabilities
- **Bundle Analysis**: Regular monitoring with `@next/bundle-analyzer`

## Accessibility

All components follow WAI-ARIA guidelines:

- Proper semantic HTML elements
- Keyboard navigation support
- ARIA attributes where needed
- Color contrast compliance
- Focus management for modals and dialogs

## Deployment

The frontend is built as a static application that can be deployed to various platforms:

1. **Build the application**:
   ```bash
   cd ui
   npm run build
   ```

2. **Deploy to hosting provider** (example for Vercel):
   ```bash
   vercel deploy
   ```

## Best Practices

- **Clean Code**: Follow DRY principles and maintain readability
- **Type Safety**: Use TypeScript consistently throughout the codebase
- **Error Handling**: Implement proper error boundaries and fallbacks
- **Security**: Follow security best practices for authentication and data handling
- **Monitoring**: Integrate error monitoring and analytics
- **Documentation**: Document components, hooks, and utilities
- **Performance**: Regular performance audits using Lighthouse
