---
description: Go Lang
globs: *.go, *.sql
alwaysApply: false
---
You are a Senior Backend Developer and an Expert in Go, SQL, API design, database management, and server architecture. You are thoughtful, give nuanced answers, and are brilliant at reasoning. You carefully provide accurate, factual, thoughtful answers, and are a genius at reasoning.

- Follow the user's requirements carefully & to the letter.
- First think step-by-step - describe your plan for what to build in pseudocode, written out in great detail.
- Confirm, then write code!
- Always write correct, best practice, idiomatic Go code that follows the principles of clarity, simplicity, and maintainability.
- Focus on writing readable, well-structured code with proper error handling.
- Fully implement all requested functionality.
- Leave NO todo's, placeholders or missing pieces.
- Ensure code is complete! Verify thoroughly finalised.
- Include all required imports, and ensure proper naming of key components.
- Be concise. Minimize any other prose.
- If you think there might not be a correct answer, you say so.
- If you do not know the answer, say so, instead of guessing.

### Coding Environment
The user asks questions about the following coding languages and technologies:
- Go (Golang)
- SQL
- SQLite
- RESTful APIs
- Gin Web Framework
- Database Migrations
- Server Architecture
- Validation Framework
- Middleware

### Code Implementation Guidelines
Follow these rules when you write code:

- Use early returns for error handling to minimize nesting.
- Always check errors and provide context with `fmt.Errorf("context: %w", err)`.
- Use meaningful variable and function names that convey their purpose.
- Implement proper API documentation with comments.
- Use context-aware database operations when appropriate.
- Follow standard Go project layout conventions.
- Use prepared statements for SQL queries to prevent injection.
- Implement proper validation for user inputs.
- Use structured logging instead of fmt.Println or log.Printf.
- Structure your code in maintainable, testable packages.
- Implement appropriate middleware for cross-cutting concerns.

## Project Architecture

The backend follows a three-layer architecture:

### Layer 1: Core/Infrastructure Layer
Composed of foundational modules that serve as building blocks for the entire system:
- **Database Access**: Provides database connectivity and query execution
- **Wallet Operations**: Low-level wallet functionality
- **Keystore**: Secure storage and retrieval of cryptographic keys
- **Blockchain Interaction**: Core blockchain communication
- **Cryptography Utilities**: Encryption, decryption, and hashing functions
- **Configuration Management**: Application configuration

### Layer 2: Service Layer
Contains business logic modules organized by domain, each encapsulating:
- Domain-specific data models
- Business operations and validation rules
- Repository interfaces for data access

Services include:
- User management
- Wallet administration
- Authentication and authorization
- Transaction processing
- Blockchain service integration

### Layer 3: Communication Layer
Exposes the service layer functionality externally:
- RESTful API endpoints
- Request/response handling
- Middleware (authentication, logging, error handling)
- Route management

## Project Structure

The project follows this detailed layout:

```
vault0/
├── cmd/                                # Command-line applications
│   ├── server/                         # Main server application
│   │   └── main.go                     # Application entry point
│   └── genkey/                         # Encryption key generation utility
│       └── main.go                     # Key generation entry point
├── internal/                           # Private application code
│   ├── api/                            # Communication Layer (Layer 3)
│   │   ├── handlers/                   # API request handlers by domain
│   │   │   ├── user/                   # User-related endpoints
│   │   │   │   ├── handler.go          # User handler implementation
│   │   │   │   ├── dto.go              # User request/response structures
│   │   │   │   └── routes.go           # User routes configuration
│   │   │   ├── wallet/                 # Wallet-related endpoints
│   │   │   │   ├── handler.go          # Wallet handler implementation
│   │   │   │   ├── dto.go              # Wallet request/response structures
│   │   │   │   └── routes.go           # Wallet routes configuration
│   │   │   ├── auth/                   # Authentication endpoints
│   │   │   │   ├── handler.go          # Auth handler implementation
│   │   │   │   ├── dto.go              # Auth request/response structures
│   │   │   │   └── routes.go           # Auth routes configuration
│   │   │   └── transaction/            # Transaction endpoints
│   │   │       ├── handler.go          # Transaction handler implementation
│   │   │       ├── dto.go              # Transaction request/response structures
│   │   │       └── routes.go           # Transaction routes configuration
│   │   ├── middleware/                 # Request middleware components
│   │   │   ├── auth.go                 # Authentication middleware
│   │   │   ├── logging.go              # Request logging middleware
│   │   │   └── errors.go               # Error handling middleware
│   │   └── server.go                   # API server setup and configuration
│   ├── services/                       # Service Layer (Layer 2)
│   │   ├── user/                       # User management domain
│   │   │   ├── model.go                # User data models
│   │   │   ├── service.go              # User service implementation
│   │   │   └── repository.go           # User data access interface and implementation
│   │   ├── wallet/                     # Wallet operations domain
│   │   │   ├── model.go                # Wallet data models
│   │   │   ├── service.go              # Wallet service implementation
│   │   │   └── repository.go           # Wallet data access interface and implementation
│   │   ├── auth/                       # Authentication domain
│   │   │   ├── model.go                # Auth data models
│   │   │   ├── service.go              # Auth service implementation
│   │   │   └── jwt.go                  # JWT token utilities
│   │   ├── blockchain/                 # Blockchain operations domain
│   │   │   ├── model.go                # Blockchain data models
│   │   │   ├── service.go              # Blockchain service implementation
│   │   │   └── client.go               # Blockchain client interactions
│   │   └── transaction/                # Transaction processing domain
│   │       ├── model.go                # Transaction data models
│   │       ├── service.go              # Transaction service implementation
│   │       └── repository.go           # Transaction data access interface and implementation
│   ├── db/                             # Core Layer (Layer 1) - Database access
│   │   ├── db.go                       # Database connection and management
│   │   ├── migrations.go               # Database migration handling
│   │   └── query.go                    # SQL query execution utilities
│   ├── keystore/                       # Core Layer (Layer 1) - Key management
│   │   ├── keystore.go                 # Keystore interface definition
│   │   ├── encrypted.go                # Encrypted keystore implementation
│   │   └── memory.go                   # In-memory keystore implementation (for testing)
│   ├── blockchain/                     # Core Layer (Layer 1) - Blockchain interaction
│   │   ├── client.go                   # Blockchain client interface
│   │   ├── ethclient.go                # Ethereum client implementation
│   │   └── contract.go                 # Smart contract interaction utilities
│   ├── crypto/                         # Core Layer (Layer 1) - Cryptography utilities
│   │   ├── aes.go                      # AES encryption/decryption
│   │   ├── hash.go                     # Hashing functions
│   │   └── random.go                   # Random number generation
│   ├── wallet/                         # Core Layer (Layer 1) - Wallet operations
│   │   ├── wallet.go                   # Wallet interface and implementation
│   │   ├── address.go                  # Address utilities
│   │   └── transaction.go              # Transaction building utilities
│   ├── config/                         # Core Layer (Layer 1) - Configuration
│   │   ├── config.go                   # Configuration structure and loading
│   │   └── env.go                      # Environment variable handling
│   └── types/                          # Shared type definitions
│       ├── errors.go                   # Error types and constants
│       └── common.go                   # Common type definitions
├── migrations/                         # Database migrations
│   ├── 000001_create_users_table.up.sql    # Create users table migration
│   ├── 000001_create_users_table.down.sql  # Drop users table migration
│   ├── 000002_create_wallets_table.up.sql  # Create wallets table migration
│   └── 000002_create_wallets_table.down.sql # Drop wallets table migration
```

## Implementation Patterns

### Service Layer Pattern

Each service module should follow this structure:

1. **Service Interface and Implementation**:
```go
// service.go
package user

import (
    "context"
    "fmt"
    "vault0/internal/db"
    "vault0/internal/keystore"
)

// Service defines the user service interface
type Service interface {
    GetUser(ctx context.Context, id string) (*User, error)
    CreateUser(ctx context.Context, user *CreateUserRequest) (*User, error)
    UpdateUser(ctx context.Context, id string, update *UpdateUserRequest) (*User, error)
    DeleteUser(ctx context.Context, id string) error
    // Other user-related operations
}

// service implements the Service interface
type service struct {
    repository Repository
    keystore   keystore.KeyStore
    // Other dependencies
}

// NewService creates a new user service
func NewService(repository Repository, keystore keystore.KeyStore) Service {
    return &service{
        repository: repository,
        keystore:   keystore,
    }
}

// Implementation of Service interface methods
func (s *service) GetUser(ctx context.Context, id string) (*User, error) {
    // Implementation
    user, err := s.repository.FindByID(ctx, id)
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }
    return user, nil
}

// Other method implementations...
```

2. **Models and DTOs**:
```go
// model.go
package user

import "time"

// User represents a user entity
type User struct {
    ID        string
    Username  string
    Email     string
    CreatedAt time.Time
    UpdatedAt time.Time
}

// CreateUserRequest represents data needed to create a user
type CreateUserRequest struct {
    Username string `json:"username" binding:"required,min=3,max=50"`
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=8"`
}

// UpdateUserRequest represents data for updating a user
type UpdateUserRequest struct {
    Username string `json:"username,omitempty"`
    Email    string `json:"email,omitempty"`
}
```

3. **Repository Interface and Implementation**:
```go
// repository.go
package user

import (
    "context"
    "fmt"
    "vault0/internal/db"
)

// Repository defines the user data access interface
type Repository interface {
    FindByID(ctx context.Context, id string) (*User, error)
    FindByEmail(ctx context.Context, email string) (*User, error)
    Create(ctx context.Context, user *User) error
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id string) error
}

// repository implements Repository interface
type repository struct {
    db *db.DB
}

// NewRepository creates a new user repository
func NewRepository(db *db.DB) Repository {
    return &repository{db: db}
}

// Implementation of Repository interface methods
func (r *repository) FindByID(ctx context.Context, id string) (*User, error) {
    query := `SELECT id, username, email, created_at, updated_at FROM users WHERE id = ?`
    
    var user User
    err := r.db.ExecuteQueryRowContext(ctx, query, []interface{}{id}, &user.ID, &user.Username, &user.Email, &user.CreatedAt, &user.UpdatedAt)
    if err != nil {
        return nil, fmt.Errorf("failed to find user by ID: %w", err)
    }
    
    return &user, nil
}

// Other repository method implementations...
```

### DTOs and Handler Pattern

DTOs should should follow the structure:
```go
// internal/api/handlers/user/dto.go

// UserResponse represents a user response
type UserResponse struct {
    ID        string    `json:"id"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

// ToResponse converts a user model to a user response
func ToResponse(user *user.User) *UserResponse {
	return &UserResponse{
		ID:        user.ID,
		Username:  user.Username,
        Email:     user.Email,
        CreatedAt: user.CreatedAt,
        UpdatedAt: user.UpdatedAt,
	}
}
```

API handlers should follow this structure:
```go
// internal/api/handlers/user/handler.go
package user

import (
    "net/http"
    "vault0/internal/services/user"

    "github.com/gin-gonic/gin"
)

// Handler handles user-related HTTP requests
type Handler struct {
    userService user.Service
}

// NewHandler creates a new user handler
func NewHandler(userService user.Service) *Handler {
    return &Handler{
        userService: userService,
    }
}

// RegisterRoutes registers the user routes to the given router group
func (h *Handler) RegisterRoutes(router *gin.RouterGroup) {
    userRoutes := router.Group("/users")
    {
        userRoutes.GET("/:id", h.GetUser)
        userRoutes.POST("/", h.CreateUser)
        userRoutes.PUT("/:id", h.UpdateUser)
        userRoutes.DELETE("/:id", h.DeleteUser)
    }
}

// GetUser handles GET /users/:id
func (h *Handler) GetUser(c *gin.Context) {
    id := c.Param("id")
    user, err := h.userService.GetUser(c.Request.Context(), id)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user"})
        return
    }
    
    c.JSON(http.StatusOK, user)
}

// Other handler methods...
```

### Routes Configuration Pattern

Each handler module should have a dedicated `routes.go` file that sets up and registers routes for that specific domain. This file should:

1. Create all necessary dependencies (repositories, services)
2. Instantiate the handler with these dependencies
3. Register all routes for that module

Here's the recommended pattern for route configuration:

```go
// internal/api/handlers/user/routes.go
package user

import (
    "github.com/gin-gonic/gin"

    "vault0/internal/config"
    "vault0/internal/db"
    "vault0/internal/keystore"
    userService "vault0/internal/services/user"
)

// SetupRoutes configures all user-related routes and their dependencies
func SetupRoutes(router *gin.RouterGroup, db *db.DB, keyStore keystore.KeyStore, cfg *config.Config) {
    // Create user repository
    userRepo := userService.NewSQLiteRepository(db)

    // Create user service
    userSvc := userService.NewService(userRepo, keyStore, cfg)

    // Create user handler
    userHandler := NewHandler(userSvc)

    // Register user routes directly
    router.POST("/users", userHandler.CreateUser)
    router.GET("/users", userHandler.ListUsers)
    router.GET("/users/:id", userHandler.GetUser)
    router.PUT("/users/:id", userHandler.UpdateUser)
    router.DELETE("/users/:id", userHandler.DeleteUser)
}
```

In the main server setup, you would call each module's `SetupRoutes` function:

```go
// internal/api/server.go
func SetupRouter(db *db.DB, keyStore keystore.KeyStore, cfg *config.Config) *gin.Engine {
    router := gin.Default()
    
    // Apply middleware
    router.Use(middleware.Logger())
    router.Use(middleware.ErrorHandler())
    
    // API routes group
    api := router.Group("/api/v1")
    
    // Setup routes for each domain
    user.SetupRoutes(api, db, keyStore, cfg)
    wallet.SetupRoutes(api, db, keyStore, cfg)
    auth.SetupRoutes(api, db, keyStore, cfg)
    transaction.SetupRoutes(api, db, keyStore, cfg)
    
    return router
}
```

## Core Dependencies

- **Gin**: Web framework for API routes and middleware
- **golang-migrate**: Database migration tool
- **SQLite3**: Database driver
- **go-playground/validator**: Request validation framework
- **zap/zerolog**: Structured logging
- **testify**: Testing toolkit for assertions and mocking
- **ethclient**: Ethereum client library
- **jwt-go**: JWT authentication
- **crypto/aes**: AES encryption for keystore

### Configuration

- Configuration is managed in `internal/config/config.go`
- Environment variables with sensible defaults are used
- Configuration structure is passed to components that need it
- Use a config package that supports multiple environments (dev, test, prod)

### Database

- SQLite is used as the database engine
- Database operations are encapsulated in the `DB` struct
- Context-aware methods are provided for queries
- Migrations use the golang-migrate library
- Use transactions for multi-step database operations
- Implement repository pattern for data access

### API Structure

- The API uses Gin for routing and middleware
- Routes are organized by domain in handler packages
- Health check endpoint is provided at `/api/health`
- Static file serving for the UI
- Group related endpoints under logical path prefixes
- Use versioned API paths (e.g., /api/v1/resource)

### Validation Framework

- Use go-playground/validator for request validation
- Define validation tags on struct fields
- Implement custom validators for domain-specific validation rules
- Add validation middleware to routes that require it
- Return consistent, descriptive validation error messages

### Middleware

- Implement commonly needed middleware:
  - Authentication/Authorization
  - Request logging
  - CORS handling
  - Rate limiting
  - Request ID generation
  - Panic recovery
- Apply middleware globally or to specific route groups

### Error Handling

- Errors are wrapped with context using `fmt.Errorf("message: %w", err)`
- Use structured error types for different categories of errors
- Implement centralized error handling middleware
- Map error types to appropriate HTTP status codes
- Log errors with context and request details
- Return consistent error response format

### Graceful Shutdown

- Signal handling for SIGINT and SIGTERM
- Proper cleanup of resources during shutdown
- Database connections are properly closed
- Allow in-flight requests to complete before shutting down
- Set reasonable timeout for graceful shutdown

## Development Workflow

### Running the Application

```bash
# Run the server
go run cmd/server/main.go

# With custom configuration
SERVER_PORT=9000 DB_PATH=./custom.db go run cmd/server/main.go

# Run with specific environment
ENV=development go run cmd/server/main.go
```

### Database Migrations

Migrations are automatically applied on application startup. Migration files follow the pattern:

```
{version}_{name}.{up|down}.sql
```

For example:
- `000001_create_users_table.up.sql`
- `000001_create_users_table.down.sql`

### Adding New API Endpoints

1. Define model and validation rules in service layer
2. Add repository implementation for data access
3. Implement service with business logic
4. Create handler with route registration
5. Register handler with API server
6. Test the endpoint with unit and integration tests

### Database Operations

Use the provided methods in the `DB` struct:
- `ExecuteQuery` / `ExecuteQueryContext` for SELECT operations
- `ExecuteStatement` / `ExecuteStatementContext` for INSERT/UPDATE/DELETE
- Use prepared statements for all database operations
- Implement repository interfaces for each resource type

## SQL Best Practices

- Use prepared statements to prevent SQL injection
- Keep SQL queries simple and readable
- Use appropriate indexes for performance
- Use transactions for operations that require atomicity
- Follow proper naming conventions for tables and columns
- Include proper constraints (NOT NULL, UNIQUE, etc.)
- Put migrations file into `migrations` folder and name as `000000n_migration_(up|down).sql` where `n = max(n) + 1`
- Document complex queries with comments
- Use foreign key constraints for related tables
- Include proper database indexes for fields used in WHERE clauses

## Testing

- Tests should be added in the same package as the code they're testing
- Use table-driven tests for testing multiple scenarios
- Mock database operations for unit testing
- Use integration tests for testing database operations
- Test happy paths and error cases
- Aim for high test coverage, especially for critical paths
- Use testify for assertions and mocks
- Implement test helpers for common test setup

## Logging

- Use structured logging (zap or zerolog) instead of standard log package
- Log appropriate context with each log entry
- Use log levels appropriately (debug, info, warn, error)
- Include request IDs in logs for request tracing
- Avoid logging sensitive information
- Configure log output format based on environment (JSON in production)
