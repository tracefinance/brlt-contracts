---
description: 
globs: internal/**/*,migrations/*,*.go,*.sql
alwaysApply: false
---
# Backend Development Guidelines (AI Optimized)

This document provides guidelines for developing the backend of the Vault0 project, optimized for AI assistant usage.

## Architecture Overview

The backend follows a three-layer architecture:

1.  **Layer 1: Core/Infrastructure (`internal/core`)**: Foundational modules (Database, Wallet Ops, Keystore, Blockchain Interaction, Crypto, Contract Interaction, Key Generation).
2.  **Layer 2: Service (`internal/services`)**: Business logic modules organized by domain (User, Wallet, Auth, Blockchain). Contains domain models, business rules, and repository interfaces.
3.  **Layer 3: Communication (`internal/api`)**: Exposes service layer functionality via RESTful API endpoints, handles requests/responses, and includes middleware.

## Project Structure

```
vault0/
├── cmd/             # Command-line applications (server, genkey)
├── internal/        # Private application code
│   ├── api/         # Layer 3: Communication (handlers, middleware, server setup)
│   ├── core/        # Layer 1: Core/Infrastructure (blockchain, contract, crypto, etc.)
│   ├── services/    # Layer 2: Service (user, wallet, auth, blockchain domains)
│   ├── config/       # Configuration management
│   ├── db/          # Database access
│   ├── errors/      # Error types and handling
│   ├── logger/      # Logging utilities
│   ├── types/       # Shared type definitions
│   └── wire/        # Dependency injection (Google Wire)
├── migrations/      # Database migrations
└── pkg/             # Public packages (if any)
```

## Implementation Patterns

### Service Layer Pattern

```go
// internal/services/wallet/service.go
package wallet

// Service defines the interface for wallet operations.
type Service interface {
    // Method signatures...
}

type service struct {
    repository Repository
    logger     logger.Logger // Example dependency
    // Other dependencies...
}

// NewService creates a new wallet service instance.
func NewService(repository Repository, logger logger.Logger) Service {
    return &service{repository: repository, logger: logger}
}

// --- Implementation of Service methods ---
```

```go
// internal/services/wallet/model.go
package wallet

import "time"

// Wallet represents the wallet entity.
type Wallet struct {
    ID        string    `db:"id"`
    UserID    string    `db:"user_id"`
    Address   string    `db:"address"`
    CreatedAt time.Time `db:"created_at"`
    UpdatedAt time.Time `db:"updated_at"`
    // Other fields...
}
```

```go
// internal/services/wallet/repository.go
package wallet

import "context"

// Repository defines the interface for wallet data access.
type Repository interface {
    FindByID(ctx context.Context, id string) (*Wallet, error)
    Create(ctx context.Context, wallet *Wallet) error
    // Other data access methods...
}

type repository struct {
    db *db.DB // Assuming db is your database connection wrapper
}

// NewRepository creates a new wallet repository instance.
func NewRepository(db *db.DB) Repository {
    return &repository{db: db}
}

// --- Implementation of Repository methods ---
```

### Handler Pattern (Gin)

```go
// internal/api/handlers/wallet/handler.go
package wallet

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "your_project/internal/services/wallet" // Adjust import path
    "your_project/internal/api/middleware"  // Adjust import path
    "your_project/internal/errors"         // Adjust import path
)

// Handler manages wallet API endpoints.
type Handler struct {
    service wallet.Service
}

// NewHandler creates a new wallet handler instance.
func NewHandler(service wallet.Service) *Handler {
    return &Handler{service: service}
}

// SetupRoutes configures routes for wallet operations.
func (h *Handler) SetupRoutes(router *gin.RouterGroup, authMiddleware gin.HandlerFunc) {
    walletRoutes := router.Group("/wallets")
    walletRoutes.Use(authMiddleware) // Apply authentication middleware
    {
        walletRoutes.POST("", h.CreateWallet)
        walletRoutes.GET("/:id", h.GetWallet)
        // Other routes...
    }
}

// CreateWallet handles POST /wallets requests.
func (h *Handler) CreateWallet(c *gin.Context) {
    var req CreateWalletRequest // Defined in dto.go
    if err := c.ShouldBindJSON(&req); err != nil {
        // Use predefined error type
        appErr := errors.NewInvalidRequestError("Invalid request body")
        c.Error(appErr) // Let middleware handle the response
        return
    }

    // Validate req...
    if req.UserID == "" {
         c.Error(errors.NewMissingParameterError("user_id"))
         return
    }

    // Call service layer
    newWallet, err := h.service.Create(c.Request.Context(), req.UserID, req.Type) // Adapt service method
    if err != nil {
        c.Error(err) // Propagate service error to middleware
        return
    }

    // Success response
    c.JSON(http.StatusCreated, NewWalletResponse(newWallet)) // Defined in dto.go
}

// GetWallet handles GET /wallets/:id requests.
func (h *Handler) GetWallet(c *gin.Context) {
    walletID := c.Param("id")
    if walletID == "" {
         c.Error(errors.NewMissingParameterError("id"))
         return
    }

    wallet, err := h.service.GetByID(c.Request.Context(), walletID) // Adapt service method
    if err != nil {
        c.Error(err)
        return
    }

    c.JSON(http.StatusOK, NewWalletResponse(wallet))
}

// dto.go would contain CreateWalletRequest, WalletResponse structs etc.
```

## Dependency Injection (Google Wire)

Located in `internal/wire`. Uses `wire.Build` with Sets for Core, Services, and Server components.

```go
// internal/wire/wire.go
//go:build wireinject
// +build wireinject

package wire

import (
    // Import necessary packages...
    "github.com/google/wire"
)

// InitializeContainer creates the main application container.
func InitializeContainer() (*Container, func(), error) {
    wire.Build(
        CoreSet,
        ServicesSet,
        ServerSet,
        NewContainer,
    )
    return nil, nil, nil // Wire will generate the implementation
}

// Container holds all major dependencies.
type Container struct {
    Config             *config.Config
    DB                 *db.DB
    Logger             logger.Logger
    KeyStore           keystore.KeyStore
    // ... other core components
    Server             *api.Server
    Services           *Services // Struct holding all service instances
}

// NewContainer creates the container (used by Wire).
func NewContainer( /* Inject dependencies here */ ) *Container {
    // ... assignment logic ...
    return &Container{ /* ... */ }
}


// internal/wire/services.go

// Services holds instances of all application services.
type Services struct {
    WalletService     wallet.Service
    UserService       user.Service
    BlockchainService blockchain.Service
    // ... other services
}

// Define Wire provider sets for each service
var WalletServiceSet = wire.NewSet(wallet.NewRepository, wallet.NewService)
var UserServiceSet = wire.NewSet(user.NewRepository, user.NewService)
// ... other service sets

// Define the set for all services
var ServicesSet = wire.NewSet(
    WalletServiceSet,
    UserServiceSet,
    // ... other service sets
    NewServices, // Provider function for the Services struct
)

// NewServices creates the Services struct (used by Wire).
func NewServices(walletSvc wallet.Service, userSvc user.Service /*... other services */) *Services {
    return &Services{
        WalletService: walletSvc,
        UserService:   userSvc,
        // ...
    }
}
```
*Remember to run `go generate ./...` in `internal/wire` to generate `wire_gen.go`.*

## Error Handling System (`internal/errors`)

Uses a custom `Vault0Error` struct with `Code`, `Message`, `Details`, and underlying `Err`.

```go
// internal/errors/errors.go
package errors

type Vault0Error struct {
    Code    string           `json:"code"`
    Message string           `json:"message"`
    Details map[string]any   `json:"details,omitempty"`
    Err     error            `json:"-"` // Underlying error
}

func (e *Vault0Error) Error() string { /* ... */ }
func (e *Vault0Error) Unwrap() error { return e.Err }
// Implement Is(), MarshalJSON()

// Constructor functions for specific errors
func NewDatabaseError(err error, operation string) *Vault0Error { /* ... */ }
func NewUserNotFoundError() *Vault0Error { /* ... */ }
func NewInvalidRequestError(details string) *Vault0Error { /* ... */ }
// ... many more constructors for Core, Service, Handler errors
```

**Principles:**

1.  **Use Predefined Constructors**: Always use functions like `errors.NewUserNotFoundError()` or `errors.NewDatabaseError(err, "query")` instead of creating errors manually.
2.  **No Wrapping Between Modules**: Catch errors from lower layers (e.g., database errors in service) and return a new, domain-specific error (e.g., `errors.NewOperationFailedError("get user", err)` or `errors.NewUserNotFoundError()`). Do NOT just wrap the DB error.
3.  **Middleware Handles API Errors**: In handlers, propagate errors using `c.Error(err)`. The `middleware.ErrorHandler` maps `Vault0Error` to HTTP status codes and JSON responses.
4.  **Log Errors**: Log errors using the structured logger *before* returning a new error type.

```go
// Bad: Wrapping
if err != nil {
    return fmt.Errorf("service failed getting user %s: %w", id, err) // DON'T DO THIS
}

// Good: Mapping and Logging
if err != nil {
    s.logger.Error("Failed to find user in repository", logger.String("user_id", id), logger.Error(err))
    if errors.Is(err, errors.ErrCodeDatabaseNotFound) { // Check underlying *type* if needed
        return nil, errors.NewUserNotFoundError()
    }
    // Return a generic service error for unexpected DB issues
    return nil, errors.NewOperationFailedError("get user by id", err)
}
```

## Development Guidelines

### Database (`internal/db`)
*   Use prepared statements.
*   Use transactions for atomicity.
*   Manage migrations (`migrations/`).

### API (`internal/api`)
*   Use standard HTTP methods and status codes.
*   Validate requests using DTOs and validation logic (use `errors.NewInvalidRequestError`, `errors.NewMissingParameterError`).
*   Use `c.Error(err)` in handlers for error propagation to middleware.
*   Document endpoints (e.g., using Swagger annotations).

### Testing (`_test.go` files)
*   Write unit and integration tests.
*   Use `testify/assert` and `testify/require`.
*   **Use `assert.ErrorContains(t, err, expectedSubstring)` or `assert.ErrorIs(t, err, errors.ErrCodeSpecificError)`**. Do *not* create custom error-checking functions.
*   Mock dependencies for unit tests.

```go
// Good assertion
assert.ErrorIs(t, err, errors.ErrCodeUserNotFound)
assert.ErrorContains(t, err, "database connection refused")

// Bad assertion (avoid string comparison if possible)
// assert.Equal(t, "user not found", err.Error())

// Bad practice: Custom check function
// func isNotFoundError(err error) bool { return errors.Is(err, errors.ErrCodeNotFound) } // DON'T DO THIS IN TESTS
```

### Security
*   Implement authentication (e.g., JWT) and authorization middleware.
*   Validate all inputs rigorously.
*   Store secrets securely (use `internal/keystore`).
*   Protect against common web vulnerabilities (OWASP Top 10).

### Performance
*   Optimize database queries (indexing, query analysis).
*   Implement caching where appropriate.
*   Use efficient algorithms and data structures.

### Logging (`internal/logger`)

Uses a structured `Logger` interface.

```go
// Logging an informational message with context
logger.Info("User created successfully",
    logger.String("user_id", newUser.ID),
    logger.String("email", newUser.Email), // Be careful logging PII
)

// Logging an error
if err != nil {
    logger.Error("Failed to process payment",
        logger.Error(err), // Include the actual error object
        logger.String("transaction_id", txID),
        logger.Float64("amount", amount),
    )
    // Propagate a domain-specific error
    return errors.NewPaymentProcessingError(err, txID)
}

// Creating a contextual logger (e.g., per request)
requestLogger := logger.With(
    logger.String("request_id", c.GetString(middleware.RequestIDKey)), // Assuming middleware adds request ID
    logger.String("remote_ip", c.ClientIP()),
)
requestLogger.Info("Handling incoming request")
```

**Logging Best Practices:**

1.  Inject `Logger` via DI.
2.  Use structured fields (`logger.String`, `logger.Int`, `logger.Error`). Use **snake_case** for field names.
3.  Keep messages concise.
4.  Include relevant context (IDs, parameters).
5.  **NEVER** log sensitive data (passwords, raw keys, PII unless masked/absolutely necessary).
6.  Use appropriate levels (`Debug`, `Info`, `Warn`, `Error`, `Fatal`).
7.  Log errors with `logger.Error(err)` field.
