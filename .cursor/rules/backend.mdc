---
description: 
globs: internal/**/*,migrations/*,*.go,*.sql
alwaysApply: false
---
# Backend Development Guidelines

## Architecture Overview

The backend follows a three-layer architecture:

### Layer 1: Core/Infrastructure Layer
Located in `internal/core`, composed of foundational modules:
- **Database Access**: Database connectivity and query execution
- **Wallet Operations**: Low-level wallet functionality
- **Keystore**: Secure storage and retrieval of cryptographic keys
- **Blockchain Interaction**: Core blockchain communication
- **Cryptography Utilities**: Encryption, decryption, and hashing functions
- **Contract Interaction**: Smart contract operation abstraction
- **Key Generation**: Cryptographic key generation utilities

### Layer 2: Service Layer
Located in `internal/services`, contains business logic modules organized by domain:
- Domain-specific data models
- Business operations and validation rules
- Repository interfaces for data access

Services include:
- User management
- Wallet administration
- Authentication and authorization
- Transaction processing
- Blockchain service integration

### Layer 3: Communication Layer
Located in `internal/api`, exposes the service layer functionality:
- RESTful API endpoints
- Request/response handling
- Middleware (authentication, logging, error handling)
- Route management

## Project Structure

```
backend/
├── cmd/                                # Command-line applications
│   ├── server/                         # Main server application
│   │   └── main.go                     # Application entry point
│   └── genkey/                         # Encryption key generation utility
│       └── main.go                     # Key generation entry point
├── internal/                           # Private application code
│   ├── api/                            # Communication Layer (Layer 3)
│   │   ├── handlers/                   # API request handlers by domain
│   │   │   ├── user/                   # User-related endpoints
│   │   │   │   ├── handler.go          # User handler implementation and route setup
│   │   │   │   ├── dto.go              # User request/response structures
│   │   │   ├── wallet/                 # Wallet-related endpoints
│   │   │   └── blockchain/             # Blockchain-related endpoints
│   │   ├── middleware/                 # Request middleware components
│   │   │   ├── auth.go                 # Authentication middleware
│   │   │   ├── logging.go              # Request logging middleware
│   │   │   └── errors.go               # Error handling middleware
│   │   └── server.go                   # API server setup and configuration
│   ├── core/                           # Core/Infrastructure Layer (Layer 1)
│   │   ├── blockchain/                 # Blockchain interaction
│   │   ├── contract/                   # Smart contract interaction
│   │   ├── crypto/                     # Cryptography utilities
│   │   ├── keygen/                     # Key generation utilities
│   │   ├── keystore/                   # Key management
│   │   └── wallet/                     # Wallet operations
│   ├── services/                       # Service Layer (Layer 2)
│   │   ├── user/                       # User management domain
│   │   ├── wallet/                     # Wallet operations domain
│   │   ├── auth/                       # Authentication domain
│   │   └── blockchain/                 # Blockchain operations domain
│   ├── config/                          # Configuration management
│   ├── db/                             # Database access
│   ├── errors/                         # Error types and handling
│   ├── logger/                         # Logging utilities
│   ├── oauth2/                         # OAuth2 implementations
│   ├── types/                          # Shared type definitions
│   └── wire/                           # Dependency injection configuration
├── migrations/                         # Database migrations
└── pkg/                                # Public packages

```

## Implementation Patterns

### Service Layer Pattern

Each service module should follow this structure:

1. **Service Interface and Implementation**:
```go
// service.go
type Service interface {
    // Service methods
}

type service struct {
    repository Repository
    // Other dependencies
}

func NewService(repository Repository) Service {
    return &service{repository: repository}
}
```

2. **Models**:
```go
// model.go
type Entity struct {
    ID        string    `db:"id"`
    CreatedAt time.Time `db:"created_at"`
    UpdatedAt time.Time `db:"updated_at"`
}
```

3. **Repository Interface and Implementation**:
```go
// repository.go
type Repository interface {
    FindByID(ctx context.Context, id string) (*Entity, error)
    Create(ctx context.Context, entity *Entity) error
}

type repository struct {
    db *db.DB
}

func NewRepository(db *db.DB) Repository {
    return &repository{db: db}
}
```

### Handler Pattern

```go
// handler.go
type Handler struct {
    service Service
}

func NewHandler(service Service) *Handler {
    return &Handler{service: service}
}

func (h *Handler) SetupRoutes(router *gin.RouterGroup) {
    router.GET("/:id", h.Get)
    router.POST("/", h.Create)
}
```

## Dependency Injection with Google Wire

The project uses Google Wire for dependency injection, organized in the `internal/wire` package.

### Wire Structure

1. **Container Definition** (`wire.go`):
```go
type Container struct {
    Config             *config.Config
    DB                 *db.DB
    Logger             logger.Logger
    KeyStore           keystore.KeyStore
    Chains             types.Chains
    WalletFactory      wallet.Factory
    BlockchainRegistry blockchain.Registry
    Server             *api.Server
    Services           *Services
}
```

2. **Core Dependencies** (`core.go`):
```go
var CoreSet = wire.NewSet(
    config.LoadConfig,
    db.NewDatabase,
    logger.NewLogger,
    keystore.NewKeyStore,
    blockchain.NewRegistry,
    wallet.NewFactory,
    contract.NewSmartContract,
    types.NewChains,
)
```

3. **Services Configuration** (`services.go`):
```go
type Services struct {
    WalletService     wallet.Service
    UserService       user.Service
    BlockchainService blockchain.Service
}

var WalletServiceSet = wire.NewSet(
	wallet.NewRepository,
	wallet.NewService,
)

var ServicesSet = wire.NewSet(
    WalletServiceSet,
    UserServiceSet,
    BlockchainServiceSet,
    NewServices,
)
```

4. **Server Configuration** (`server.go`):
```go
var ServerSet = wire.NewSet(
    wallet.NewHandler,
    user.NewHandler,
    blockchain.NewHandler,
    api.NewServer,
)
```

## Error Handling System

The project implements a comprehensive error handling system with a structured approach to creating, propagating, and handling errors across all layers.

### Core Error Structure

All application errors should use the `Vault0Error` type defined in `internal/errors/errors.go`:

```go
type Vault0Error struct {
    // Code is a unique identifier for the error type
    Code string `json:"code"`
    // Message is a human-readable error message
    Message string `json:"message"`
    // Details contains additional error context (optional)
    Details map[string]any `json:"details,omitempty"`
    // Err is the underlying error (not exposed in JSON)
    Err error `json:"-"`
}
```

The `Vault0Error` type implements the standard error interface and provides additional methods for error identification and context:
- `Error()`: Returns a formatted error message
- `Unwrap()`: Returns the underlying error
- `Is()`: Enables error comparison with `errors.Is()`
- `MarshalJSON()`: Provides custom JSON serialization

### Layer-Specific Error Types

#### Layer 1: Core/Infrastructure Errors (`internal/errors/core.go`)

Core-level components should use error types defined in `internal/errors/core.go`, organized by domain:

- **Database Errors**: `ErrCodeDatabaseError`, `ErrCodeDatabaseNotFound`
- **Blockchain Errors**: `ErrCodeBlockchainError`, `ErrCodeChainNotSupported`, etc.
- **Keystore Errors**: `ErrCodeKeystoreError`, `ErrCodeKeyNotFound`
- **Wallet Errors**: `ErrCodeWalletError`, `ErrCodeInvalidWalletConfig`
- **Crypto Errors**: `ErrCodeCryptoError`, `ErrCodeEncryptionError`
- **Explorer Errors**: `ErrCodeExplorerError`, `ErrCodeRateLimitExceeded`

Example usage:
```go
// Instead of generic errors
if err != nil {
    return fmt.Errorf("failed to decrypt key: %w", err)
}

// Use structured errors
if err != nil {
    return errors.NewDecryptionError(err)
}
```

#### Layer 2: Service Errors (`internal/errors/services.go`)

Service-level components should use error types defined in `internal/errors/services.go`:

- **Common Service Errors**: `ErrCodeInvalidInput`, `ErrCodeNotFound`
- **Wallet Service Errors**: `ErrCodeWalletNotFound`, `ErrCodeWalletExists`
- **User Service Errors**: `ErrCodeUserNotFound`, `ErrCodeInvalidCredentials`
- **Transaction Service Errors**: `ErrCodeTransactionSyncFailed`

Example usage:
```go
func (s *service) GetUser(ctx context.Context, id string) (*User, error) {
    user, err := s.repository.FindByID(ctx, id)
    if err != nil {
        // Don't propagate database errors directly
        if errors.Is(err, errors.ErrCodeDatabaseNotFound) {
            return nil, errors.NewUserNotFoundError()
        }
        return nil, errors.NewOperationFailedError("get user", err)
    }
    return user, nil
}
```

#### Layer 3: Handler Errors (`internal/errors/handlers.go`)

API handlers should use error types defined in `internal/errors/handlers.go`:

- **Request Validation**: `ErrCodeValidationError`, `ErrCodeInvalidRequest`
- **Authentication**: `ErrCodeUnauthorized`, `ErrCodeInvalidAccessToken`
- **Response Errors**: `ErrCodeInternalError`, `ErrCodeServiceUnavailable`

Example usage:
```go
func (h *handler) CreateUser(c *gin.Context) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.Error(errors.NewInvalidRequestError("Invalid request format"))
        return
    }
    
    if req.Name == "" {
        c.Error(errors.NewMissingParameterError("name"))
        return
    }
    
    // Process the request...
}
```

### Error Handling in API Layer

The API layer uses a middleware-based approach to handle errors consistently:

1. **Error Middleware Configuration**:

```go
// In handler setup
func (h *Handler) SetupRoutes(router *gin.RouterGroup) {
    // Create error handler middleware
    errorHandler := middleware.NewErrorHandler(nil)
    
    // Apply middleware to routes group
    routes := router.Group("/resource")
    routes.Use(errorHandler.Middleware())
    
    // Setup routes
    routes.POST("", h.Create)
    routes.GET("/:id", h.Get)
    // ...
}
```

2. **Error Propagation in Handlers**:

```go
func (h *Handler) GetResource(c *gin.Context) {
    id := c.Param("id")
    
    // Get the resource
    resource, err := h.service.Get(c.Request.Context(), id)
    if err != nil {
        // Propagate the error to the middleware
        c.Error(err)
        return
    }
    
    // Success response
    c.JSON(http.StatusOK, resource)
}
```

3. **Error Mapping**:

The error middleware automatically maps `Vault0Error` instances to appropriate HTTP status codes and JSON responses:

- Layer 1 errors typically map to 500-level errors (server errors)
- Layer 2 errors map to either 400-level errors (client errors) or 500-level errors depending on the error type
- Layer 3 errors map directly to their corresponding HTTP status codes

Customized error mapping can be implemented by providing a custom mapper to the error handler:

```go
func CustomErrorMapper(err error) (int, any) {
    // Custom error mapping logic
    // ...
}

errorHandler := middleware.NewErrorHandler(CustomErrorMapper)
```

### Error Handling Principles

1. **No Error Wrapping Between Modules**
   - Don't wrap errors from other modules; create new domain-specific errors
   - Each module should define its own error types and codes
   - Use the predefined error constructors from the `errors` package

2. **Clear Error Categories**
   - Use appropriate error codes based on the error context
   - Include relevant details in error messages
   - Add context information to the `Details` field when helpful

3. **Error Handling in Services**
   - Services should not expose errors from lower layers directly
   - Map infrastructure errors to domain-specific errors
   - Include appropriate context in error details

4. **Error Handling in API**
   - Use middleware to convert `Vault0Error` to HTTP responses
   - Log internal errors but return safe error messages to clients
   - Convert unexpected errors to internal server errors

### Logging Errors

When handling errors, ensure proper logging for debugging and monitoring:

```go
if err != nil {
    // Log the error with context
    logger.WithContext(ctx).WithError(err).Error("Failed to process transaction")
    
    // Return a domain-specific error
    return errors.NewTransactionFailedError(err)
}
```

## Development Guidelines

### Database Operations
- Use prepared statements for all SQL queries
- Implement proper connection pooling
- Use transactions for atomic operations
- Include proper database indexes
- Handle database migrations properly

### API Design
- Use proper HTTP methods
- Implement proper validation
- Use proper status codes
- Include proper error responses
- Document API endpoints
- Implement proper rate limiting

### Testing
- Write unit tests for all components
- Implement integration tests
- Use proper mocking
- Test error scenarios
- Test edge cases
- Maintain high test coverage
- **Do not create custom error checking functions**, use `assert.ErrorContains` instead:
  ```go
  // Good practice
  assert.ErrorContains(t, err, "Keystore operation failed")
  
  // Avoid creating custom error checking functions
  func IsKeystoreError(err error) bool {
	return err != nil && err.Error() == ErrCodeKeystoreError
  }
  ```

### Security
- Implement proper authentication
- Use proper authorization
- Validate all inputs
- Use proper encryption
- Handle sensitive data properly
- Implement rate limiting
- Monitor for security issues

### Performance
- Optimize database queries
- Implement proper caching
- Use proper indexing
- Handle large datasets efficiently
- Monitor performance metrics
- Implement proper pagination

### Logging
The application uses a structured logging interface defined in `internal/logger/logger.go`:

```go
type Logger interface {
    Debug(msg string, fields ...Field)
    Info(msg string, fields ...Field)
    Warn(msg string, fields ...Field)
    Error(msg string, fields ...Field)
    Fatal(msg string, fields ...Field)
    With(fields ...Field) Logger
}
```

#### Usage Guidelines
**1. Dependency Injection**

Always accept the logger as a dependency in services and components:

```go
type service struct {
    repository Repository
    logger     logger.Logger
}

func NewService(repository Repository, logger logger.Logger) Service {
    return &service{repository: repository, logger: logger}
}
```

**2. Structured Logging**
```go
// Don't: 
l.Info(fmt.Sprintf("Processing %s", txID))

// Do:
l.Info("Processing transaction", 
    logger.String("transaction_id", txID),
    logger.String("user_id", userID))
```

**3. Contextual Logging**
```go
reqLogger := logger.With(
    logger.String("request_id", requestID),
    logger.String("user_id", userID),
)
```

**4. Error Logging**
```go
if err != nil {
    logger.Error("Operation failed", 
        logger.Error(err),
        logger.String("context", "additional info"))
    return errors.NewAppropriateError(err)
}
```
#### Field Types
```go
logger.String("key", "value")
logger.Int("count", 42)
logger.Float64("ratio", 0.9)
logger.Bool("enabled", true)
logger.Duration("elapsed", time.Since(start))
logger.Time("timestamp", time.Now())
logger.Error(err)
logger.Any("data", complexStruct)
```

#### Best Practices

1. **Use snake_case for field names**
2. **Keep messages concise and descriptive**
3. **Include operation context** (IDs, parameters)
4. **Never log sensitive information**
5. **Use appropriate log levels**
6. **In API handlers**: 
   - Include request_id for correlation
7. **In services**:
   - Include relevant IDs and parameters
8. **With errors**:
   - Always include the error object using `logger.Error(err)`
   - Log context around the error
   - Return appropriate domain error types