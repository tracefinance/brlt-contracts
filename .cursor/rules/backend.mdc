---
description: 
globs: internal/**/*,migrations/*,*.go,*.sql
alwaysApply: false
---
# Backend Development Guidelines (AI Optimized)

This document provides guidelines for developing the backend of the Vault0 project, optimized for AI assistant usage.

## Architecture Overview

The backend follows a three-layer architecture:

1.  **Layer 1: Core/Infrastructure (`internal/core`)**: Foundational modules (Database, Wallet Ops, Keystore, Blockchain Interaction, Crypto, Contract Interaction, Key Generation).
2.  **Layer 2: Service (`internal/services`)**: Business logic modules organized by domain (User, Wallet, Auth, Blockchain). Contains domain models, business rules, and repository interfaces.
3.  **Layer 3: Communication (`internal/api`)**: Exposes service layer functionality via RESTful API endpoints, handles requests/responses, and includes middleware.

## Project Structure

```
vault0/
├── cmd/             # Command-line applications (server, genkey)
├── internal/        # Private application code
│   ├── api/         # Layer 3: Communication (handlers, middleware, server setup)
│   ├── core/        # Layer 1: Core/Infrastructure - Foundational modules
│   │   ├── wallet/        # Wallet address deriation, transaction encoding and signing
│   │   ├── pricefeed/     # Real-time price data retrieval for assets
│   │   ├── tokenstore/    # Management of supported tokens and their metadata
│   │   ├── keystore/      # Secure storage and retrieval of cryptographic keys
│   │   ├── keygen/        # Generation of cryptographic keys
│   │   ├── crypto/        # Cryptographic primitives and utilities (hashing, signing)
│   │   ├── blockexplorer/ # Interaction with blockchain explorers for transaction data
│   │   ├── contract/      # Smart contract interaction logic (ABIs,  deploy and methods)
│   │   └── blockchain/    # Core blockchain interaction (clients, node connections)
│   ├── services/    # Layer 2: Service (user, wallet, auth, blockchain domains)
│   ├── config/      # Configuration management
│   ├── db/          # Database access
│   ├── errors/      # Error types and handling
│   ├── logger/      # Logging utilities
│   ├── types/       # Shared type definitions
│   └── wire/        # Dependency injection (Google Wire)
├── migrations/      # Database migrations
└── pkg/             # Public packages (if any)
```

## Token-Based Pagination System

The project uses token-based pagination implemented in `internal/types/page.go` with the following components:

```go
// NextPageToken represents pagination state for cursor-based pagination
type NextPageToken struct {
    Column string `json:"c"` // Database column used for cursor
    Value any `json:"v"`     // Value to compare against
}

// Page represents a paginated response for any type
type Page[T any] struct {
    Items []T    `json:"items"`                // Items on current page
    NextToken string `json:"next_token,omitempty"` // Token for next page
    Limit int     `json:"limit"`               // Maximum items per page
}
```

Key functions:
- `EncodeNextPageToken`: Converts a token to base64 string
- `DecodeNextPageToken`: Parses a base64 string into a token
- `NewPage`: Creates a paginated response with token generation

### Repository Pagination Pattern

```go
// List retrieves items with token-based pagination
func (r *repository) List(ctx context.Context, limit int, nextToken string) (*types.Page[*Item], error) {
    // Default pagination column 
    paginationColumn := "id"
    
    // Decode token and apply criteria
    token, err := types.DecodeNextPageToken(nextToken, paginationColumn)
    if err != nil {
        return nil, err
    }

    // Build query with token condition
    sb := r.structMap.SelectFrom("items")
    sb.Where(sb.IsNull("deleted_at"))
    
    if token != nil {
        sb.Where(sb.GreaterThan(paginationColumn, token.Value))
    }
    
    // Order and limit
    sb.OrderBy(paginationColumn + " ASC")
    if limit > 0 {
        sb.Limit(limit + 1) // Fetch +1 to check if more pages exist
    }
    
    // Execute query
    items, err := r.executeQuery(ctx, sql, args...)
    if err != nil {
        return nil, err
    }
    
    // Generate token function
    generateToken := func(item *Item) *types.NextPageToken {
        return &types.NextPageToken{
            Column: paginationColumn,
            Value: item.ID,
        }
    }
    
    return types.NewPage(items, limit, generateToken), nil
}
```

### Service Pagination Pattern

```go
func (s *service) List(ctx context.Context, limit int, nextToken string) (*types.Page[*Item], error) {
    // Apply default limit for negative values
    if limit < 0 {
        limit = 10
    }
    
    return s.repository.List(ctx, limit, nextToken)
}
```

### Handler Pagination Pattern

```go
func (h *Handler) List(c *gin.Context) {
    var req ListRequest
    if err := c.ShouldBindQuery(&req); err != nil {
        c.Error(err)
        return
    }
    
    // Set default limit if not provided
    limit := 10
    if req.Limit != nil {
        limit = *req.Limit
    }
    
    // Get paginated items
    page, err := h.service.List(c.Request.Context(), limit, req.NextToken)
    if err != nil {
        c.Error(err)
        return
    }
    
    // Transform to response format
    c.JSON(http.StatusOK, utils.NewPagedResponse(page, ToResponse))
}
```

## Implementation Patterns

### Service Layer Pattern

```go
// internal/services/wallet/service.go
package wallet

// Service defines the interface for wallet operations.
type Service interface {
    // Method signatures...
}

type service struct {
    repository Repository
    logger     logger.Logger // Example dependency
    // Other dependencies...
}

// NewService creates a new wallet service instance.
func NewService(repository Repository, logger logger.Logger) Service {
    return &service{repository: repository, logger: logger}
}

// --- Implementation of Service methods ---
```

```go
// internal/services/wallet/model.go
package wallet

import "time"

// Wallet represents the wallet entity.
type Wallet struct {
    ID        string    `db:"id"`
    UserID    string    `db:"user_id"`
    Address   string    `db:"address"`
    CreatedAt time.Time `db:"created_at"`
    UpdatedAt time.Time `db:"updated_at"`
    // Other fields...
}
```

```go
// internal/services/wallet/repository.go
package wallet

import "context"

// Repository defines the interface for wallet data access.
type Repository interface {
    FindByID(ctx context.Context, id string) (*Wallet, error)
    Create(ctx context.Context, wallet *Wallet) error
    // Other data access methods...
}

type repository struct {
    db *db.DB // Assuming db is your database connection wrapper
}

// NewRepository creates a new wallet repository instance.
func NewRepository(db *db.DB) Repository {
    return &repository{db: db}
}

// --- Implementation of Repository methods ---
```

### Handler Pattern (Gin)

```go
// internal/api/handlers/wallet/handler.go
package wallet

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "your_project/internal/services/wallet" // Adjust import path
    "your_project/internal/api/middleware"  // Adjust import path
    "your_project/internal/errors"         // Adjust import path
)

// Handler manages wallet API endpoints.
type Handler struct {
    service wallet.Service
}

// NewHandler creates a new wallet handler instance.
func NewHandler(service wallet.Service) *Handler {
    return &Handler{service: service}
}

// SetupRoutes configures routes for wallet operations.
func (h *Handler) SetupRoutes(router *gin.RouterGroup, authMiddleware gin.HandlerFunc) {
    walletRoutes := router.Group("/wallets")
    walletRoutes.Use(authMiddleware) // Apply authentication middleware
    {
        walletRoutes.POST("", h.CreateWallet)
        walletRoutes.GET("/:id", h.GetWallet)
        // Other routes...
    }
}

// CreateWallet handles POST /wallets requests.
func (h *Handler) CreateWallet(c *gin.Context) {
    var req CreateWalletRequest // Defined in dto.go
    if err := c.ShouldBindJSON(&req); err != nil {
        // Use predefined error type
        appErr := errors.NewInvalidRequestError("Invalid request body")
        c.Error(appErr) // Let middleware handle the response
        return
    }

    // Validate req...
    if req.UserID == "" {
         c.Error(errors.NewMissingParameterError("user_id"))
         return
    }

    // Call service layer
    newWallet, err := h.service.Create(c.Request.Context(), req.UserID, req.Type) // Adapt service method
    if err != nil {
        c.Error(err) // Propagate service error to middleware
        return
    }

    // Success response
    c.JSON(http.StatusCreated, NewWalletResponse(newWallet)) // Defined in dto.go
}

// GetWallet handles GET /wallets/:id requests.
func (h *Handler) GetWallet(c *gin.Context) {
    walletID := c.Param("id")
    if walletID == "" {
         c.Error(errors.NewMissingParameterError("id"))
         return
    }

    wallet, err := h.service.GetByID(c.Request.Context(), walletID) // Adapt service method
    if err != nil {
        c.Error(err)
        return
    }

    c.JSON(http.StatusOK, NewWalletResponse(wallet))
}

// dto.go would contain CreateWalletRequest, WalletResponse structs etc.
```

## Dependency Injection (Google Wire)

Located in `internal/wire`. Uses `wire.Build` with Sets for Core, Services, and Server components.

```go
// internal/wire/wire.go
//go:build wireinject
// +build wireinject

package wire

import (
    // Import necessary packages...
    "github.com/google/wire"
)

// InitializeContainer creates the main application container.
func InitializeContainer() (*Container, func(), error) {
    wire.Build(
        CoreSet,
        ServicesSet,
        ServerSet,
        NewContainer,
    )
    return nil, nil, nil // Wire will generate the implementation
}

// Container holds all major dependencies.
type Container struct {
    Config             *config.Config
    DB                 *db.DB
    Logger             logger.Logger
    KeyStore           keystore.KeyStore
    // ... other core components
    Server             *api.Server
    Services           *Services // Struct holding all service instances
}

// NewContainer creates the container (used by Wire).
func NewContainer( /* Inject dependencies here */ ) *Container {
    // ... assignment logic ...
    return &Container{ /* ... */ }
}


// internal/wire/services.go

// Services holds instances of all application services.
type Services struct {
    WalletService     wallet.Service
    UserService       user.Service
    BlockchainService blockchain.Service
    // ... other services
}

// Define Wire provider sets for each service
var WalletServiceSet = wire.NewSet(wallet.NewRepository, wallet.NewService)
var UserServiceSet = wire.NewSet(user.NewRepository, user.NewService)
// ... other service sets

// Define the set for all services
var ServicesSet = wire.NewSet(
    WalletServiceSet,
    UserServiceSet,
    // ... other service sets
    NewServices, // Provider function for the Services struct
)

// NewServices creates the Services struct (used by Wire).
func NewServices(walletSvc wallet.Service, userSvc user.Service /*... other services */) *Services {
    return &Services{
        WalletService: walletSvc,
        UserService:   userSvc,
        // ...
    }
}
```
*Remember to run `go generate ./...` in `internal/wire` to generate `wire_gen.go`.*

### Wire Setup Pattern for New Service

When adding a new service (like a Notification service), follow this pattern:

1. Update `internal/wire/services.go`:
```go
// Add import
import "vault0/internal/services/notification"

// Update Services struct
type Services struct {
    // Existing services...
    NotificationService notification.Service
}

// Define provider set
var NotificationServiceSet = wire.NewSet(
    notification.NewRepository,
    notification.NewService,
)

// Add to ServicesSet
var ServicesSet = wire.NewSet(
    // Existing service sets...
    NotificationServiceSet,
    NewServices,
)

// Update NewServices function parameters and return struct
func NewServices(
    // Existing parameters...
    notificationSvc notification.Service,
) *Services {
    return &Services{
        // Existing assignments...
        NotificationService: notificationSvc,
    }
}
```

2. Update `internal/wire/server.go`:
```go
// Add import
import "vault0/internal/api/handlers/notification"

var ServerSet = wire.NewSet(
    // Existing handlers...
    notification.NewHandler,
    api.NewServer,
)
```

## Error Handling System (`internal/errors`)

Uses a custom `Vault0Error` struct with `Code`, `Message`, `Details`, and underlying `Err`.

```go
// internal/errors/errors.go
package errors

type Vault0Error struct {
    Code    string           `json:"code"`
    Message string           `json:"message"`
    Details map[string]any   `json:"details,omitempty"`
    Err     error            `json:"-"` // Underlying error
}

func (e *Vault0Error) Error() string { /* ... */ }
func (e *Vault0Error) Unwrap() error { return e.Err }
// Implement Is(), MarshalJSON()

// Constructor functions for specific errors
func NewDatabaseError(err error, operation string) *Vault0Error { /* ... */ }
func NewUserNotFoundError() *Vault0Error { /* ... */ }
func NewInvalidRequestError(details string) *Vault0Error { /* ... */ }
// ... many more constructors for Core, Service, Handler errors
```

**Principles:**

1.  **Use Predefined Constructors**: Always use functions like `errors.NewUserNotFoundError()` or `errors.NewDatabaseError(err, "query")` instead of creating errors manually.
2.  **No Wrapping Between Modules**: Catch errors from lower layers (e.g., database errors in service) and return a new, domain-specific error (e.g., `errors.NewOperationFailedError("get user", err)` or `errors.NewUserNotFoundError()`). Do NOT just wrap the DB error.
3.  **Middleware Handles API Errors**: In handlers, propagate errors using `c.Error(err)`. The `middleware.ErrorHandler` maps `Vault0Error` to HTTP status codes and JSON responses.
4.  **Log Errors**: Log errors using the structured logger *before* returning a new error type.

```go
// Bad: Wrapping
if err != nil {
    return fmt.Errorf("service failed getting user %s: %w", id, err) // DON'T DO THIS
}

// Good: Mapping and Logging
if err != nil {
    s.logger.Error("Failed to find user in repository", logger.String("user_id", id), logger.Error(err))
    if errors.Is(err, errors.ErrCodeDatabaseNotFound) { // Check underlying *type* if needed
        return nil, errors.NewUserNotFoundError()
    }
    // Return a generic service error for unexpected DB issues
    return nil, errors.NewOperationFailedError("get user by id", err)
}
```

## Development Guidelines

### Database (`internal/db`)
*   Use prepared statements.
*   Use transactions for atomicity.
*   Manage migrations (`migrations/`).

### API (`internal/api`)
*   Use standard HTTP methods and status codes.
*   Validate requests using DTOs and validation logic (use `errors.NewInvalidRequestError`, `errors.NewMissingParameterError`).
*   Use `c.Error(err)` in handlers for error propagation to middleware.
*   Document endpoints (e.g., using Swagger annotations).

### Testing (`_test.go` files)
*   Write unit and integration tests.
*   Use `testify/assert` and `testify/require`.
*   **Use `assert.ErrorContains(t, err, expectedSubstring)` or `assert.ErrorIs(t, err, errors.ErrCodeSpecificError)`**. Do *not* create custom error-checking functions.
*   Mock dependencies for unit tests.

```go
// Good assertion
assert.ErrorIs(t, err, errors.ErrCodeUserNotFound)
assert.ErrorContains(t, err, "database connection refused")

// Bad assertion (avoid string comparison if possible)
// assert.Equal(t, "user not found", err.Error())

// Bad practice: Custom check function
// func isNotFoundError(err error) bool { return errors.Is(err, errors.ErrCodeNotFound) } // DON'T DO THIS IN TESTS
```

### Security
*   Implement authentication (e.g., JWT) and authorization middleware.
*   Validate all inputs rigorously.
*   Store secrets securely (use `internal/keystore`).
*   Protect against common web vulnerabilities (OWASP Top 10).

### Performance
*   Optimize database queries (indexing, query analysis).
*   Implement caching where appropriate.
*   Use efficient algorithms and data structures.

### Logging (`internal/logger`)

Uses a structured `Logger` interface.

```go
// Logging an informational message with context
logger.Info("User created successfully",
    logger.String("user_id", newUser.ID),
    logger.String("email", newUser.Email), // Be careful logging PII
)

// Logging an error
if err != nil {
    logger.Error("Failed to process payment",
        logger.Error(err), // Include the actual error object
        logger.String("transaction_id", txID),
        logger.Float64("amount", amount),
    )
    // Propagate a domain-specific error
    return errors.NewPaymentProcessingError(err, txID)
}

// Creating a contextual logger (e.g., per request)
requestLogger := logger.With(
    logger.String("request_id", c.GetString(middleware.RequestIDKey)), // Assuming middleware adds request ID
    logger.String("remote_ip", c.ClientIP()),
)
requestLogger.Info("Handling incoming request")
```

**Logging Best Practices:**

1.  Inject `Logger` via DI.
2.  Use structured fields (`logger.String`, `logger.Int`, `logger.Error`). Use **snake_case** for field names.
3.  Keep messages concise.
4.  Include relevant context (IDs, parameters).
5.  **NEVER** log sensitive data (passwords, raw keys, PII unless masked/absolutely necessary).
6.  Use appropriate levels (`Debug`, `Info`, `Warn`, `Error`, `Fatal`).
7.  Log errors with `logger.Error(err)` field.

## New Feature Implementation Guide

When implementing a new feature, follow this sequence:

1. **Start with the data model**
   - Define the entity/struct in `internal/services/[domain]/model.go`
   - Include proper db tags and validation logic

2. **Define the repository interface and implementation**
   - Create `internal/services/[domain]/repository.go`
   - Implement CRUD operations and pagination following the standard pattern

3. **Define and implement the service interface**
   - Create `internal/services/[domain]/service.go`
   - Implement business logic with proper error handling and validation

4. **Add API DTOs and handlers**
   - Define request/response models in `internal/api/handlers/[domain]/dto.go`
   - Implement handler methods in `internal/api/handlers/[domain]/handler.go`

5. **Wire up dependency injection**
   - Add service to `internal/wire/services.go`
   - Add handler to `internal/wire/server.go`

6. **Add database migrations**
   - Create migration files in `migrations/`

7. **Implement unit and integration tests**
   - Create `_test.go` files for repository, service, and handler
