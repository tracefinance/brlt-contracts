// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"github.com/google/wire"
	"vault0/internal/api"
	blockchain3 "vault0/internal/api/handlers/blockchain"
	user2 "vault0/internal/api/handlers/user"
	wallet3 "vault0/internal/api/handlers/wallet"
	"vault0/internal/config"
	"vault0/internal/core/blockchain"
	"vault0/internal/core/db"
	"vault0/internal/core/keystore"
	"vault0/internal/core/wallet"
	"vault0/internal/logger"
	blockchain2 "vault0/internal/services/blockchain"
	"vault0/internal/services/user"
	wallet2 "vault0/internal/services/wallet"
	"vault0/internal/types"
)

// Injectors from wire.go:

// InitializeContainer creates a new container with all dependencies wired up
// BuildContainer is a placeholder function that will be replaced by wire with the actual implementation
func BuildContainer() (*Container, error) {
	configConfig := config.LoadConfig()
	dbDB, err := db.NewDatabase(configConfig)
	if err != nil {
		return nil, err
	}
	loggerLogger, err := logger.NewLogger(configConfig)
	if err != nil {
		return nil, err
	}
	keyStore, err := keystore.NewKeyStore(dbDB, configConfig)
	if err != nil {
		return nil, err
	}
	chains, err := types.NewChains(configConfig)
	if err != nil {
		return nil, err
	}
	factory := wallet.NewFactory(keyStore, chains, configConfig)
	registry := blockchain.NewRegistry(chains, configConfig)
	repository := user.NewRepository(dbDB)
	service := user.NewService(repository)
	handler := user2.NewHandler(service)
	walletRepository := wallet2.NewRepository(dbDB)
	walletService := wallet2.NewService(configConfig, loggerLogger, walletRepository, keyStore, factory, registry, chains)
	walletHandler := wallet3.NewHandler(walletService)
	blockchainRepository := blockchain2.NewRepository(dbDB)
	blockchainService := blockchain2.NewService(blockchainRepository, walletService, registry)
	blockchainHandler := blockchain3.NewHandler(blockchainService)
	server := api.NewServer(loggerLogger, configConfig, handler, walletHandler, blockchainHandler)
	services := NewServices(walletService, service, blockchainService)
	container := NewContainer(configConfig, dbDB, loggerLogger, keyStore, chains, factory, registry, server, services)
	return container, nil
}

// wire.go:

// Container holds all application dependencies
type Container struct {
	Config             *config.Config
	DB                 *db.DB
	Logger             logger.Logger
	KeyStore           keystore.KeyStore
	Chains             types.Chains
	WalletFactory      wallet.Factory
	BlockchainRegistry blockchain.Registry
	Server             *api.Server
	Services           *Services
}

// NewContainer creates a new dependency injection container
func NewContainer(config2 *config.Config, db2 *db.DB, logger2 logger.Logger,

	keyStore keystore.KeyStore,
	chains types.Chains,
	walletFactory wallet.Factory,
	blockchainRegistry blockchain.Registry,
	server *api.Server,
	services *Services,
) *Container {
	return &Container{
		Config:             config2,
		DB:                 db2,
		Logger:             logger2,
		KeyStore:           keyStore,
		Chains:             chains,
		WalletFactory:      walletFactory,
		BlockchainRegistry: blockchainRegistry,
		Server:             server,
		Services:           services,
	}
}

// ContainerSet combines all dependency sets
var ContainerSet = wire.NewSet(
	CoreSet,
	ServerSet,
	ServicesSet,
	NewContainer,
)
