# Vault0 Project Intelligence

## Critical Implementation Patterns

1. **Three-Layer Architecture**
   - All backend code follows a strict separation between core, service, and API layers
   - References should flow downward only (API → Service → Core)
   - Each layer should have well-defined interfaces

2. **Interface-First Development**
   - All components define interfaces before implementations
   - Dependency injection is used throughout the codebase
   - Mock implementations are used for testing

3. **Repository Pattern**
   - All data access is through repository interfaces
   - SQL queries should not be scattered throughout the application
   - Each domain entity has its own repository

## User Preferences

1. **Code Style**
   - Go code follows standard Go formatting with gofmt
   - Error handling uses proper context and wrapping
   - Function names use PascalCase for exports, camelCase for private functions
   - Comments use full sentences with periods

2. **Documentation**
   - All interfaces should have godoc comments
   - Complex algorithms need detailed documentation
   - Public APIs need clear documentation of parameters and return values

3. **Testing**
   - All business logic requires unit tests
   - Repository implementations need integration tests
   - API endpoints should have end-to-end tests

## Project-Specific Patterns

1. **Error Handling**
   - Domain-specific errors should be defined in the service layer
   - API responses should include structured error information
   - Logging should include correlation IDs for request tracing

2. **Authentication Flow**
   - OAuth2 used for all authentication
   - OAuth2 tokens stored in the database
   - Authentication middleware applied to protected endpoints

3. **Blockchain Interaction**
   - Abstracted through interfaces in the core layer
   - Implementation specific to EVM-compatible chains
   - Error handling includes retry logic for transient errors

## Known Challenges

1. **Database Limitations**
   - SQLite has limitations for concurrent access
   - Production deployment may need a more robust database

2. **Private Key Security**
   - Keys must be encrypted at rest
   - Multiple layers of security for access

3. **Cross-Chain Compatibility**
   - Base and Polygon zkEVM have slightly different behaviors
   - Gas estimation varies between chains

## Ongoing Decisions

1. **Frontend Technology Stack**
   - Next.js chosen for the application
   - React and TypeScript for component implementation
   - TailwindCSS for styling

2. **API Design**
   - RESTful API for core operations
   - Standardized response formats
   - Pagination for list responses

3. **Token Support**
   - Initial focus on native coins and basic ERC20 tokens
   - Whitelist approach for security
   - Future consideration for other token standards

## Tool Usage Patterns

1. **Development Workflow**
   - `make` commands for common operations
   - Local development uses SQLite
   - Contract development uses Hardhat

2. **Testing Strategy**
   - Unit tests for business logic
   - Integration tests for repositories
   - Contract tests for smart contract behavior

3. **Deployment**
   - Separate commands for different environments
   - Contract verification part of deployment process
